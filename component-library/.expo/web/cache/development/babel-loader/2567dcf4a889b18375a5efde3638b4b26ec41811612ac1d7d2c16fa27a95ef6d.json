{"ast":null,"code":"\"use strict\";\n\nvar _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\nvar _asyncToGenerator = require(\"@babel/runtime/helpers/asyncToGenerator\");\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.compositeImagesAsync = exports.generateFaviconAsync = exports.generateImageAsync = void 0;\nvar chalk_1 = __importDefault(require(\"chalk\"));\nvar mime_1 = __importDefault(require(\"mime\"));\nvar Cache = __importStar(require(\"./Cache\"));\nvar Download = __importStar(require(\"./Download\"));\nvar Ico = __importStar(require(\"./Ico\"));\nvar env_1 = require(\"./env\");\nvar Jimp = __importStar(require(\"./jimp\"));\nvar Sharp = __importStar(require(\"./sharp\"));\nvar supportedMimeTypes = ['image/png', 'image/jpeg', 'image/webp', 'image/gif'];\nvar hasWarned = false;\nfunction resizeImagesAsync(_x, _x2) {\n  return _resizeImagesAsync.apply(this, arguments);\n}\nfunction _resizeImagesAsync() {\n  _resizeImagesAsync = _asyncToGenerator(function* (buffer, sizes) {\n    var sharp = yield getSharpAsync();\n    if (!sharp) {\n      return Jimp.resizeBufferAsync(buffer, sizes);\n    }\n    return Sharp.resizeBufferAsync(buffer, sizes);\n  });\n  return _resizeImagesAsync.apply(this, arguments);\n}\nfunction resizeAsync(_x3) {\n  return _resizeAsync.apply(this, arguments);\n}\nfunction _resizeAsync() {\n  _resizeAsync = _asyncToGenerator(function* (imageOptions) {\n    var sharp = yield getSharpAsync();\n    var width = imageOptions.width,\n      height = imageOptions.height,\n      backgroundColor = imageOptions.backgroundColor,\n      resizeMode = imageOptions.resizeMode;\n    if (!sharp) {\n      var inputOptions = {\n        input: imageOptions.src,\n        quality: 100\n      };\n      var jimp = yield Jimp.resize(inputOptions, {\n        width: width,\n        height: height,\n        fit: resizeMode,\n        background: backgroundColor\n      });\n      if (imageOptions.removeTransparency) {\n        jimp.colorType(2);\n      }\n      if (imageOptions.borderRadius) {\n        yield Jimp.circleAsync(jimp);\n      }\n      return jimp.getBufferAsync('image/png');\n    }\n    try {\n      var sharpBuffer = sharp(imageOptions.src).ensureAlpha().resize(width, height, {\n        fit: resizeMode,\n        background: 'transparent'\n      });\n      if (backgroundColor && backgroundColor !== 'transparent') {\n        sharpBuffer = sharpBuffer.composite([{\n          input: {\n            create: {\n              width: width,\n              height: height,\n              channels: imageOptions.removeTransparency ? 3 : 4,\n              background: backgroundColor\n            }\n          },\n          blend: 'dest-over'\n        }]);\n      } else if (imageOptions.removeTransparency) {\n        sharpBuffer.flatten();\n      }\n      if (imageOptions.borderRadius) {\n        var mask = Buffer.from(\"<svg><rect x=\\\"0\\\" y=\\\"0\\\" width=\\\"\" + width + \"\\\" height=\\\"\" + height + \"\\\"\\n        rx=\\\"\" + imageOptions.borderRadius + \"\\\" ry=\\\"\" + imageOptions.borderRadius + \"\\\"\\n        fill=\\\"\" + (backgroundColor && backgroundColor !== 'transparent' ? backgroundColor : 'none') + \"\\\" /></svg>\");\n        sharpBuffer.composite([{\n          input: mask,\n          blend: 'dest-in'\n        }]);\n      }\n      return yield sharpBuffer.png().toBuffer();\n    } catch (_ref2) {\n      var message = _ref2.message;\n      throw new Error(\"It was not possible to generate splash screen '\" + imageOptions.src + \"'. \" + message);\n    }\n  });\n  return _resizeAsync.apply(this, arguments);\n}\nfunction getSharpAsync() {\n  return _getSharpAsync.apply(this, arguments);\n}\nfunction _getSharpAsync() {\n  _getSharpAsync = _asyncToGenerator(function* () {\n    var sharp;\n    if (yield Sharp.isAvailableAsync()) sharp = yield Sharp.findSharpInstanceAsync();\n    return sharp;\n  });\n  return _getSharpAsync.apply(this, arguments);\n}\nfunction getDimensionsId(imageOptions) {\n  return imageOptions.width === imageOptions.height ? \"\" + imageOptions.width : imageOptions.width + \"x\" + imageOptions.height;\n}\nfunction maybeWarnAboutInstallingSharpAsync() {\n  return _maybeWarnAboutInstallingSharpAsync.apply(this, arguments);\n}\nfunction _maybeWarnAboutInstallingSharpAsync() {\n  _maybeWarnAboutInstallingSharpAsync = _asyncToGenerator(function* () {\n    if (env_1.env.EXPO_IMAGE_UTILS_DEBUG && !hasWarned && !(yield Sharp.isAvailableAsync())) {\n      hasWarned = true;\n      console.warn(chalk_1.default.yellow(\"Using node to generate images. This is much slower than using native packages.\\n\\u203A Optionally you can stop the process and try again after successfully running `npm install -g sharp-cli`.\\n\"));\n    }\n  });\n  return _maybeWarnAboutInstallingSharpAsync.apply(this, arguments);\n}\nfunction ensureImageOptionsAsync(_x4) {\n  return _ensureImageOptionsAsync.apply(this, arguments);\n}\nfunction _ensureImageOptionsAsync() {\n  _ensureImageOptionsAsync = _asyncToGenerator(function* (imageOptions) {\n    var icon = _objectSpread(_objectSpread({}, imageOptions), {}, {\n      src: yield Download.downloadOrUseCachedImage(imageOptions.src)\n    });\n    if (!icon.resizeMode) {\n      icon.resizeMode = 'contain';\n    }\n    var mimeType = mime_1.default.getType(icon.src);\n    if (!mimeType) {\n      throw new Error(\"Invalid mimeType for image with source: \" + icon.src);\n    }\n    if (!supportedMimeTypes.includes(mimeType)) {\n      throw new Error(\"Supplied image is not a supported image type: \" + imageOptions.src);\n    }\n    if (!icon.name) {\n      icon.name = \"icon_\" + getDimensionsId(imageOptions) + \".\" + mime_1.default.getExtension(mimeType);\n    }\n    return icon;\n  });\n  return _ensureImageOptionsAsync.apply(this, arguments);\n}\nfunction generateImageAsync(_x5, _x6) {\n  return _generateImageAsync.apply(this, arguments);\n}\nfunction _generateImageAsync() {\n  _generateImageAsync = _asyncToGenerator(function* (options, imageOptions) {\n    var icon = yield ensureImageOptionsAsync(imageOptions);\n    if (!options.cacheType) {\n      yield maybeWarnAboutInstallingSharpAsync();\n      return {\n        name: icon.name,\n        source: yield resizeAsync(icon)\n      };\n    }\n    var cacheKey = yield Cache.createCacheKeyWithDirectoryAsync(options.projectRoot, options.cacheType, icon);\n    var name = icon.name;\n    var source = yield Cache.getImageFromCacheAsync(name, cacheKey);\n    if (!source) {\n      yield maybeWarnAboutInstallingSharpAsync();\n      source = yield resizeAsync(icon);\n      yield Cache.cacheImageAsync(name, source, cacheKey);\n    }\n    return {\n      name: name,\n      source: source\n    };\n  });\n  return _generateImageAsync.apply(this, arguments);\n}\nexports.generateImageAsync = generateImageAsync;\nfunction generateFaviconAsync(_x7) {\n  return _generateFaviconAsync.apply(this, arguments);\n}\nfunction _generateFaviconAsync() {\n  _generateFaviconAsync = _asyncToGenerator(function* (pngImageBuffer) {\n    var sizes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [16, 32, 48];\n    var buffers = yield resizeImagesAsync(pngImageBuffer, sizes);\n    return yield Ico.generateAsync(buffers);\n  });\n  return _generateFaviconAsync.apply(this, arguments);\n}\nexports.generateFaviconAsync = generateFaviconAsync;\nfunction compositeImagesAsync(_x8) {\n  return _compositeImagesAsync.apply(this, arguments);\n}\nfunction _compositeImagesAsync() {\n  _compositeImagesAsync = _asyncToGenerator(function* (_ref) {\n    var foreground = _ref.foreground,\n      background = _ref.background,\n      _ref$x = _ref.x,\n      x = _ref$x === void 0 ? 0 : _ref$x,\n      _ref$y = _ref.y,\n      y = _ref$y === void 0 ? 0 : _ref$y;\n    var sharp = yield getSharpAsync();\n    if (!sharp) {\n      var image = (yield Jimp.getJimpImageAsync(background)).composite(yield Jimp.getJimpImageAsync(foreground), x, y);\n      return yield image.getBufferAsync(image.getMIME());\n    }\n    return yield sharp(background).composite([{\n      input: foreground,\n      left: x,\n      top: y\n    }]).toBuffer();\n  });\n  return _compositeImagesAsync.apply(this, arguments);\n}\nexports.compositeImagesAsync = compositeImagesAsync;","map":{"version":3,"names":["chalk_1","__importDefault","require","mime_1","Cache","__importStar","Download","Ico","env_1","Jimp","Sharp","supportedMimeTypes","hasWarned","resizeImagesAsync","_x","_x2","_resizeImagesAsync","apply","arguments","_asyncToGenerator","buffer","sizes","sharp","getSharpAsync","resizeBufferAsync","resizeAsync","_x3","_resizeAsync","imageOptions","width","height","backgroundColor","resizeMode","inputOptions","input","src","quality","jimp","resize","fit","background","removeTransparency","colorType","borderRadius","circleAsync","getBufferAsync","sharpBuffer","ensureAlpha","composite","create","channels","blend","flatten","mask","Buffer","from","png","toBuffer","_ref2","message","Error","_getSharpAsync","isAvailableAsync","findSharpInstanceAsync","getDimensionsId","maybeWarnAboutInstallingSharpAsync","_maybeWarnAboutInstallingSharpAsync","env","EXPO_IMAGE_UTILS_DEBUG","console","warn","default","yellow","ensureImageOptionsAsync","_x4","_ensureImageOptionsAsync","icon","_objectSpread","downloadOrUseCachedImage","mimeType","getType","includes","name","getExtension","generateImageAsync","_x5","_x6","_generateImageAsync","options","cacheType","source","cacheKey","createCacheKeyWithDirectoryAsync","projectRoot","getImageFromCacheAsync","cacheImageAsync","exports","generateFaviconAsync","_x7","_generateFaviconAsync","pngImageBuffer","length","undefined","buffers","generateAsync","compositeImagesAsync","_x8","_compositeImagesAsync","_ref","foreground","_ref$x","x","_ref$y","y","image","getJimpImageAsync","getMIME","left","top"],"sources":["/Users/henriqueeidt/Documents/Projects/poc-web-mobile-components/component-library/node_modules/expo-pwa/node_modules/@expo/image-utils/src/Image.ts"],"sourcesContent":["import chalk from 'chalk';\nimport mime from 'mime';\n\nimport * as Cache from './Cache';\nimport * as Download from './Download';\nimport * as Ico from './Ico';\nimport { ImageOptions } from './Image.types';\nimport { env } from './env';\nimport * as Jimp from './jimp';\nimport * as Sharp from './sharp';\n\nconst supportedMimeTypes = ['image/png', 'image/jpeg', 'image/webp', 'image/gif'];\n\nlet hasWarned: boolean = false;\n\nasync function resizeImagesAsync(buffer: Buffer, sizes: number[]): Promise<Buffer[]> {\n  const sharp = await getSharpAsync();\n  if (!sharp) {\n    return Jimp.resizeBufferAsync(buffer, sizes);\n  }\n  return Sharp.resizeBufferAsync(buffer, sizes);\n}\n\nasync function resizeAsync(imageOptions: ImageOptions): Promise<Buffer> {\n  const sharp: any = await getSharpAsync();\n  const { width, height, backgroundColor, resizeMode } = imageOptions;\n  if (!sharp) {\n    const inputOptions: any = { input: imageOptions.src, quality: 100 };\n    const jimp = await Jimp.resize(inputOptions, {\n      width,\n      height,\n      fit: resizeMode,\n      background: backgroundColor,\n    });\n\n    if (imageOptions.removeTransparency) {\n      jimp.colorType(2);\n    }\n    if (imageOptions.borderRadius) {\n      // TODO: support setting border radius with Jimp. Currently only support making the image a circle\n      await Jimp.circleAsync(jimp);\n    }\n\n    // Convert to png buffer\n    return jimp.getBufferAsync('image/png');\n  }\n  try {\n    let sharpBuffer = sharp(imageOptions.src)\n      .ensureAlpha()\n      .resize(width, height, { fit: resizeMode, background: 'transparent' });\n\n    // Skip an extra step if the background is explicitly transparent.\n    if (backgroundColor && backgroundColor !== 'transparent') {\n      // Add the background color to the image\n      sharpBuffer = sharpBuffer.composite([\n        {\n          // create a background color\n          input: {\n            create: {\n              width,\n              height,\n              // allow alpha colors\n              channels: imageOptions.removeTransparency ? 3 : 4,\n              background: backgroundColor,\n            },\n          },\n          // dest-over makes the first image (input) appear on top of the created image (background color)\n          blend: 'dest-over',\n        },\n      ]);\n    } else if (imageOptions.removeTransparency) {\n      sharpBuffer.flatten();\n    }\n\n    if (imageOptions.borderRadius) {\n      const mask = Buffer.from(\n        `<svg><rect x=\"0\" y=\"0\" width=\"${width}\" height=\"${height}\"\n        rx=\"${imageOptions.borderRadius}\" ry=\"${imageOptions.borderRadius}\"\n        fill=\"${\n          backgroundColor && backgroundColor !== 'transparent' ? backgroundColor : 'none'\n        }\" /></svg>`\n      );\n\n      sharpBuffer.composite([{ input: mask, blend: 'dest-in' }]);\n    }\n\n    return await sharpBuffer.png().toBuffer();\n  } catch ({ message }) {\n    throw new Error(\n      `It was not possible to generate splash screen '${imageOptions.src}'. ${message}`\n    );\n  }\n}\n\nasync function getSharpAsync(): Promise<any> {\n  let sharp: any;\n  if (await Sharp.isAvailableAsync()) sharp = await Sharp.findSharpInstanceAsync();\n  return sharp;\n}\n\nfunction getDimensionsId(imageOptions: Pick<ImageOptions, 'width' | 'height'>): string {\n  return imageOptions.width === imageOptions.height\n    ? `${imageOptions.width}`\n    : `${imageOptions.width}x${imageOptions.height}`;\n}\n\nasync function maybeWarnAboutInstallingSharpAsync() {\n  // Putting the warning here will prevent the warning from showing if all images were reused from the cache\n  if (env.EXPO_IMAGE_UTILS_DEBUG && !hasWarned && !(await Sharp.isAvailableAsync())) {\n    hasWarned = true;\n    console.warn(\n      chalk.yellow(\n        `Using node to generate images. This is much slower than using native packages.\\n\\u203A Optionally you can stop the process and try again after successfully running \\`npm install -g sharp-cli\\`.\\n`\n      )\n    );\n  }\n}\n\nasync function ensureImageOptionsAsync(imageOptions: ImageOptions): Promise<ImageOptions> {\n  const icon = {\n    ...imageOptions,\n    src: await Download.downloadOrUseCachedImage(imageOptions.src),\n  };\n\n  // Default to contain\n  if (!icon.resizeMode) {\n    icon.resizeMode = 'contain';\n  }\n\n  const mimeType = mime.getType(icon.src);\n\n  if (!mimeType) {\n    throw new Error(`Invalid mimeType for image with source: ${icon.src}`);\n  }\n  if (!supportedMimeTypes.includes(mimeType)) {\n    throw new Error(`Supplied image is not a supported image type: ${imageOptions.src}`);\n  }\n\n  if (!icon.name) {\n    icon.name = `icon_${getDimensionsId(imageOptions)}.${mime.getExtension(mimeType)}`;\n  }\n\n  return icon;\n}\n\nexport async function generateImageAsync(\n  options: { projectRoot: string; cacheType?: string },\n  imageOptions: ImageOptions\n): Promise<{ source: Buffer; name: string }> {\n  const icon = await ensureImageOptionsAsync(imageOptions);\n\n  if (!options.cacheType) {\n    await maybeWarnAboutInstallingSharpAsync();\n    return { name: icon.name!, source: await resizeAsync(icon) };\n  }\n\n  const cacheKey = await Cache.createCacheKeyWithDirectoryAsync(\n    options.projectRoot,\n    options.cacheType,\n    icon\n  );\n\n  const name = icon.name!;\n  let source: Buffer | null = await Cache.getImageFromCacheAsync(name, cacheKey);\n\n  if (!source) {\n    await maybeWarnAboutInstallingSharpAsync();\n    source = await resizeAsync(icon);\n    await Cache.cacheImageAsync(name, source, cacheKey);\n  }\n\n  return { name, source };\n}\n\nexport async function generateFaviconAsync(\n  pngImageBuffer: Buffer,\n  sizes: number[] = [16, 32, 48]\n): Promise<Buffer> {\n  const buffers = await resizeImagesAsync(pngImageBuffer, sizes);\n  return await Ico.generateAsync(buffers);\n}\n\n/**\n * Layers the provided foreground image over the provided background image.\n *\n * @param foregroundImageBuffer\n * @param foregroundImageBuffer\n * @param x pixel offset from the left edge, defaults to 0.\n * @param y pixel offset from the top edge, defaults to 0.\n */\nexport async function compositeImagesAsync({\n  foreground,\n  background,\n  x = 0,\n  y = 0,\n}: {\n  foreground: Buffer;\n  background: Buffer;\n  x?: number;\n  y?: number;\n}): Promise<Buffer> {\n  const sharp: any = await getSharpAsync();\n  if (!sharp) {\n    const image = (await Jimp.getJimpImageAsync(background)).composite(\n      await Jimp.getJimpImageAsync(foreground),\n      x,\n      y\n    );\n    return await image.getBufferAsync(image.getMIME());\n  }\n  return await sharp(background)\n    .composite([{ input: foreground, left: x, top: y }])\n    .toBuffer();\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}
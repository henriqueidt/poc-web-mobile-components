{"ast":null,"code":"\"use strict\";\n\nvar _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\nvar _asyncToGenerator = require(\"@babel/runtime/helpers/asyncToGenerator\");\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.resize = exports.getJimpImageAsync = exports.circleAsync = exports.isFolderAsync = exports.jimpAsync = exports.convertFormat = exports.resizeBufferAsync = void 0;\nvar fs_extra_1 = __importDefault(require(\"fs-extra\"));\nvar jimp_compact_1 = __importDefault(require(\"jimp-compact\"));\nvar path = __importStar(require(\"path\"));\nfunction resizeBufferAsync(_x, _x2) {\n  return _resizeBufferAsync.apply(this, arguments);\n}\nfunction _resizeBufferAsync() {\n  _resizeBufferAsync = _asyncToGenerator(function* (buffer, sizes) {\n    return Promise.all(sizes.map(function () {\n      var _ref5 = _asyncToGenerator(function* (size) {\n        var jimpImage = yield jimp_compact_1.default.read(buffer);\n        var mime = jimpImage.getMIME();\n        return jimpImage.resize(size, size).getBufferAsync(mime);\n      });\n      return function (_x10) {\n        return _ref5.apply(this, arguments);\n      };\n    }()));\n  });\n  return _resizeBufferAsync.apply(this, arguments);\n}\nexports.resizeBufferAsync = resizeBufferAsync;\nfunction convertFormat(format) {\n  if (typeof format === 'undefined') return format;\n  var input = format === null || format === void 0 ? void 0 : format.toLowerCase();\n  switch (input) {\n    case 'png':\n    case 'webp':\n    case 'jpeg':\n      return \"image/\" + input;\n    case 'jpg':\n      return \"image/jpeg\";\n  }\n  return undefined;\n}\nexports.convertFormat = convertFormat;\nfunction jimpAsync(_x3) {\n  return _jimpAsync.apply(this, arguments);\n}\nfunction _jimpAsync() {\n  _jimpAsync = _asyncToGenerator(function* (options) {\n    var commands = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    if (commands.length) {\n      var command = commands.shift();\n      if (command) {\n        var input;\n        if (command.operation === 'resize') {\n          input = yield resize(options, command);\n        } else if (command.operation === 'flatten') {\n          input = yield flatten(options, command);\n        } else {\n          throw new Error(\"The operation: '\" + command.operation + \"' is not supported with Jimp\");\n        }\n        return jimpAsync(_objectSpread(_objectSpread({}, options), {}, {\n          input: input\n        }), commands);\n      }\n    }\n    var image = yield getJimpImageAsync(options.input);\n    var mime = typeof options.format === 'string' ? options.format : image.getMIME();\n    var imgBuffer = yield image.getBufferAsync(mime);\n    if (typeof options.output === 'string') {\n      if (yield isFolderAsync(options.output)) {\n        yield fs_extra_1.default.writeFile(path.join(options.output, path.basename(options.originalInput)), imgBuffer);\n      } else {\n        yield fs_extra_1.default.writeFile(options.output, imgBuffer);\n      }\n    }\n    return imgBuffer;\n  });\n  return _jimpAsync.apply(this, arguments);\n}\nexports.jimpAsync = jimpAsync;\nfunction isFolderAsync(_x4) {\n  return _isFolderAsync.apply(this, arguments);\n}\nfunction _isFolderAsync() {\n  _isFolderAsync = _asyncToGenerator(function* (path) {\n    try {\n      return (yield fs_extra_1.default.stat(path)).isDirectory();\n    } catch (_unused) {\n      return false;\n    }\n  });\n  return _isFolderAsync.apply(this, arguments);\n}\nexports.isFolderAsync = isFolderAsync;\nfunction circleAsync(jimp) {\n  var radius = Math.min(jimp.bitmap.width, jimp.bitmap.height) / 2;\n  var center = {\n    x: jimp.bitmap.width / 2,\n    y: jimp.bitmap.height / 2\n  };\n  return new Promise(function (resolve) {\n    jimp.scanQuiet(0, 0, jimp.bitmap.width, jimp.bitmap.height, function (x, y, idx) {\n      var curR = Math.sqrt(Math.pow(x - center.x, 2) + Math.pow(y - center.y, 2));\n      if (radius - curR <= 0.0) {\n        jimp.bitmap.data[idx + 3] = 0;\n      } else if (radius - curR < 1.0) {\n        jimp.bitmap.data[idx + 3] = 255 * (radius - curR);\n      }\n      resolve(jimp);\n    });\n  });\n}\nexports.circleAsync = circleAsync;\nfunction getJimpImageAsync(_x5) {\n  return _getJimpImageAsync.apply(this, arguments);\n}\nfunction _getJimpImageAsync() {\n  _getJimpImageAsync = _asyncToGenerator(function* (input) {\n    if (typeof input === 'string' || input instanceof Buffer) return yield jimp_compact_1.default.read(input);\n    return input;\n  });\n  return _getJimpImageAsync.apply(this, arguments);\n}\nexports.getJimpImageAsync = getJimpImageAsync;\nfunction resize(_x6, _x7) {\n  return _resize.apply(this, arguments);\n}\nfunction _resize() {\n  _resize = _asyncToGenerator(function* (_ref, _ref2) {\n    var input = _ref.input,\n      _ref$quality = _ref.quality,\n      quality = _ref$quality === void 0 ? 100 : _ref$quality;\n    var background = _ref2.background,\n      position = _ref2.position,\n      fit = _ref2.fit,\n      width = _ref2.width,\n      height = _ref2.height;\n    var initialImage = yield getJimpImageAsync(input);\n    if (width && !height) {\n      height = jimp_compact_1.default.AUTO;\n    } else if (!width && height) {\n      width = jimp_compact_1.default.AUTO;\n    } else if (!width && !height) {\n      width = initialImage.bitmap.width;\n      height = initialImage.bitmap.height;\n    }\n    var jimpPosition = convertPosition(position);\n    var jimpQuality = typeof quality !== 'number' ? 100 : quality;\n    if (fit === 'cover') {\n      initialImage = initialImage.cover(width, height, jimpPosition);\n    } else if (fit === 'contain') {\n      initialImage = initialImage.contain(width, height, jimpPosition);\n    } else {\n      throw new Error(\"Unsupported fit: \" + fit + \". Please choose either 'cover', or 'contain' when using Jimp\");\n    }\n    if (background) {\n      initialImage = initialImage.composite(new jimp_compact_1.default(width, height, background), 0, 0, {\n        mode: jimp_compact_1.default.BLEND_DESTINATION_OVER,\n        opacitySource: 1,\n        opacityDest: 1\n      });\n    }\n    return yield initialImage.quality(jimpQuality);\n  });\n  return _resize.apply(this, arguments);\n}\nexports.resize = resize;\nfunction flatten(_x8, _x9) {\n  return _flatten.apply(this, arguments);\n}\nfunction _flatten() {\n  _flatten = _asyncToGenerator(function* (_ref3, _ref4) {\n    var input = _ref3.input,\n      _ref3$quality = _ref3.quality,\n      quality = _ref3$quality === void 0 ? 100 : _ref3$quality;\n    var background = _ref4.background;\n    var initialImage = yield getJimpImageAsync(input);\n    var jimpQuality = typeof quality !== 'number' ? 100 : quality;\n    return initialImage.quality(jimpQuality).background(jimp_compact_1.default.cssColorToHex(background));\n  });\n  return _flatten.apply(this, arguments);\n}\nfunction convertPosition(position) {\n  if (!position) return convertPosition('center');\n  switch (position) {\n    case 'center':\n    case 'centre':\n      return jimp_compact_1.default.VERTICAL_ALIGN_MIDDLE | jimp_compact_1.default.HORIZONTAL_ALIGN_CENTER;\n    case 'north':\n    case 'top':\n      return jimp_compact_1.default.VERTICAL_ALIGN_TOP | jimp_compact_1.default.HORIZONTAL_ALIGN_CENTER;\n    case 'east':\n    case 'right':\n      return jimp_compact_1.default.VERTICAL_ALIGN_MIDDLE | jimp_compact_1.default.HORIZONTAL_ALIGN_RIGHT;\n    case 'south':\n    case 'bottom':\n      return jimp_compact_1.default.VERTICAL_ALIGN_BOTTOM | jimp_compact_1.default.HORIZONTAL_ALIGN_CENTER;\n    case 'west':\n    case 'left':\n      return jimp_compact_1.default.VERTICAL_ALIGN_MIDDLE | jimp_compact_1.default.HORIZONTAL_ALIGN_LEFT;\n    case 'northeast':\n    case 'right top':\n      return jimp_compact_1.default.VERTICAL_ALIGN_TOP | jimp_compact_1.default.HORIZONTAL_ALIGN_RIGHT;\n    case 'southeast':\n    case 'right bottom':\n      return jimp_compact_1.default.VERTICAL_ALIGN_BOTTOM | jimp_compact_1.default.HORIZONTAL_ALIGN_RIGHT;\n    case 'southwest':\n    case 'left bottom':\n      return jimp_compact_1.default.VERTICAL_ALIGN_BOTTOM | jimp_compact_1.default.HORIZONTAL_ALIGN_LEFT;\n    case 'northwest':\n    case 'left top':\n      return jimp_compact_1.default.VERTICAL_ALIGN_TOP | jimp_compact_1.default.HORIZONTAL_ALIGN_LEFT;\n    case 'entropy':\n    case 'attention':\n      throw new Error(\"Position: '\" + position + \"' is not supported\");\n    default:\n      throw new Error(\"Unknown position: '\" + position + \"'\");\n  }\n}","map":{"version":3,"names":["fs_extra_1","__importDefault","require","jimp_compact_1","path","__importStar","resizeBufferAsync","_x","_x2","_resizeBufferAsync","apply","arguments","_asyncToGenerator","buffer","sizes","Promise","all","map","_ref5","size","jimpImage","default","read","mime","getMIME","resize","getBufferAsync","_x10","exports","convertFormat","format","input","toLowerCase","undefined","jimpAsync","_x3","_jimpAsync","options","commands","length","command","shift","operation","flatten","Error","_objectSpread","image","getJimpImageAsync","imgBuffer","output","isFolderAsync","writeFile","join","basename","originalInput","_x4","_isFolderAsync","stat","isDirectory","_unused","circleAsync","jimp","radius","Math","min","bitmap","width","height","center","x","y","resolve","scanQuiet","idx","curR","sqrt","pow","data","_x5","_getJimpImageAsync","Buffer","_x6","_x7","_resize","_ref","_ref2","_ref$quality","quality","background","position","fit","initialImage","AUTO","jimpPosition","convertPosition","jimpQuality","cover","contain","composite","mode","BLEND_DESTINATION_OVER","opacitySource","opacityDest","_x8","_x9","_flatten","_ref3","_ref4","_ref3$quality","cssColorToHex","VERTICAL_ALIGN_MIDDLE","HORIZONTAL_ALIGN_CENTER","VERTICAL_ALIGN_TOP","HORIZONTAL_ALIGN_RIGHT","VERTICAL_ALIGN_BOTTOM","HORIZONTAL_ALIGN_LEFT"],"sources":["/Users/henriqueeidt/Documents/Projects/poc-web-mobile-components/component-library/node_modules/expo-pwa/node_modules/@expo/image-utils/src/jimp.ts"],"sourcesContent":["import fs from 'fs-extra';\n// @ts-ignore\nimport Jimp from 'jimp-compact';\nimport * as path from 'path';\n\nimport {\n  FlattenOptions,\n  Position,\n  ResizeOptions,\n  SharpCommandOptions,\n  SharpGlobalOptions,\n} from './sharp.types';\n\ntype JimpGlobalOptions = Omit<SharpGlobalOptions, 'input'> & {\n  input: string | Buffer | Jimp;\n  originalInput: string;\n};\n\nexport async function resizeBufferAsync(buffer: Buffer, sizes: number[]): Promise<Buffer[]> {\n  return Promise.all(\n    sizes.map(async size => {\n      // Parse the buffer each time to prevent mutable copies.\n      // Parse the buffer each time to prevent mutable copies.\n      const jimpImage = await Jimp.read(buffer);\n      const mime = jimpImage.getMIME();\n\n      return jimpImage.resize(size, size).getBufferAsync(mime);\n    })\n  );\n}\n\nexport function convertFormat(format?: string): string | undefined {\n  if (typeof format === 'undefined') return format;\n\n  const input = format?.toLowerCase();\n  switch (input) {\n    case 'png':\n    case 'webp':\n    case 'jpeg':\n      return `image/${input}`;\n    case 'jpg':\n      return `image/jpeg`;\n  }\n  return undefined;\n}\n\nexport async function jimpAsync(\n  options: JimpGlobalOptions,\n  commands: SharpCommandOptions[] = []\n): Promise<Buffer> {\n  if (commands.length) {\n    const command = commands.shift();\n    if (command) {\n      let input: Jimp;\n      if (command.operation === 'resize') {\n        input = await resize(options, command);\n      } else if (command.operation === 'flatten') {\n        input = await flatten(options, command);\n      } else {\n        throw new Error(`The operation: '${command.operation}' is not supported with Jimp`);\n      }\n      // @ts-ignore\n      return jimpAsync({ ...options, input }, commands);\n    }\n  }\n\n  const image = await getJimpImageAsync(options.input);\n  const mime = typeof options.format === 'string' ? options.format : image.getMIME();\n  const imgBuffer = await image.getBufferAsync(mime);\n\n  if (typeof options.output === 'string') {\n    if (await isFolderAsync(options.output)) {\n      await fs.writeFile(\n        path.join(options.output, path.basename(options.originalInput)),\n        imgBuffer\n      );\n    } else {\n      await fs.writeFile(options.output, imgBuffer);\n    }\n  }\n  return imgBuffer;\n}\n\nexport async function isFolderAsync(path: string): Promise<boolean> {\n  try {\n    return (await fs.stat(path)).isDirectory();\n  } catch {\n    return false;\n  }\n}\n\nexport function circleAsync(jimp: Jimp): Promise<Jimp> {\n  const radius = Math.min(jimp.bitmap.width, jimp.bitmap.height) / 2;\n\n  const center = {\n    x: jimp.bitmap.width / 2,\n    y: jimp.bitmap.height / 2,\n  };\n\n  return new Promise(resolve => {\n    jimp.scanQuiet(\n      0,\n      0,\n      jimp.bitmap.width,\n      jimp.bitmap.height,\n      (x: number, y: number, idx: number) => {\n        const curR = Math.sqrt(Math.pow(x - center.x, 2) + Math.pow(y - center.y, 2));\n\n        if (radius - curR <= 0.0) {\n          jimp.bitmap.data[idx + 3] = 0;\n        } else if (radius - curR < 1.0) {\n          jimp.bitmap.data[idx + 3] = 255 * (radius - curR);\n        }\n        resolve(jimp);\n      }\n    );\n  });\n}\n\nexport async function getJimpImageAsync(input: string | Buffer | Jimp): Promise<Jimp> {\n  // @ts-ignore: Jimp types are broken\n  if (typeof input === 'string' || input instanceof Buffer) return await Jimp.read(input);\n\n  return input;\n}\n\nexport async function resize(\n  { input, quality = 100 }: JimpGlobalOptions,\n  { background, position, fit, width, height }: Omit<ResizeOptions, 'operation'>\n): Promise<Jimp> {\n  let initialImage = await getJimpImageAsync(input);\n\n  if (width && !height) {\n    height = Jimp.AUTO;\n  } else if (!width && height) {\n    width = Jimp.AUTO;\n  } else if (!width && !height) {\n    width = initialImage.bitmap.width;\n    height = initialImage.bitmap.height;\n  }\n\n  const jimpPosition = convertPosition(position);\n  const jimpQuality = typeof quality !== 'number' ? 100 : quality;\n  if (fit === 'cover') {\n    initialImage = initialImage.cover(width, height, jimpPosition);\n  } else if (fit === 'contain') {\n    initialImage = initialImage.contain(width, height, jimpPosition);\n  } else {\n    throw new Error(\n      `Unsupported fit: ${fit}. Please choose either 'cover', or 'contain' when using Jimp`\n    );\n  }\n  if (background) {\n    initialImage = initialImage.composite(new Jimp(width, height, background), 0, 0, {\n      mode: Jimp.BLEND_DESTINATION_OVER,\n      opacitySource: 1,\n      opacityDest: 1,\n    });\n  }\n\n  return await initialImage.quality(jimpQuality);\n}\n\nasync function flatten(\n  { input, quality = 100 }: JimpGlobalOptions,\n  { background }: Omit<FlattenOptions, 'operation'>\n): Promise<Jimp> {\n  const initialImage = await getJimpImageAsync(input);\n  const jimpQuality = typeof quality !== 'number' ? 100 : quality;\n  return initialImage.quality(jimpQuality).background(Jimp.cssColorToHex(background));\n}\n\n/**\n * Convert sharp position to Jimp position.\n *\n * @param position\n */\nfunction convertPosition(position?: Position): number {\n  if (!position) return convertPosition('center');\n\n  switch (position) {\n    case 'center':\n    case 'centre':\n      return Jimp.VERTICAL_ALIGN_MIDDLE | Jimp.HORIZONTAL_ALIGN_CENTER;\n    case 'north':\n    case 'top':\n      return Jimp.VERTICAL_ALIGN_TOP | Jimp.HORIZONTAL_ALIGN_CENTER;\n    case 'east':\n    case 'right':\n      return Jimp.VERTICAL_ALIGN_MIDDLE | Jimp.HORIZONTAL_ALIGN_RIGHT;\n    case 'south':\n    case 'bottom':\n      return Jimp.VERTICAL_ALIGN_BOTTOM | Jimp.HORIZONTAL_ALIGN_CENTER;\n    case 'west':\n    case 'left':\n      return Jimp.VERTICAL_ALIGN_MIDDLE | Jimp.HORIZONTAL_ALIGN_LEFT;\n    case 'northeast':\n    case 'right top':\n      return Jimp.VERTICAL_ALIGN_TOP | Jimp.HORIZONTAL_ALIGN_RIGHT;\n    case 'southeast':\n    case 'right bottom':\n      return Jimp.VERTICAL_ALIGN_BOTTOM | Jimp.HORIZONTAL_ALIGN_RIGHT;\n    case 'southwest':\n    case 'left bottom':\n      return Jimp.VERTICAL_ALIGN_BOTTOM | Jimp.HORIZONTAL_ALIGN_LEFT;\n    case 'northwest':\n    case 'left top':\n      return Jimp.VERTICAL_ALIGN_TOP | Jimp.HORIZONTAL_ALIGN_LEFT;\n    case 'entropy':\n    case 'attention':\n      throw new Error(`Position: '${position}' is not supported`);\n    default:\n      throw new Error(`Unknown position: '${position}'`);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}
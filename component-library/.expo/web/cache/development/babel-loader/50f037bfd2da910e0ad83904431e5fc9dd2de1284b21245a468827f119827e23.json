{"ast":null,"code":"\"use strict\";\nvar _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\nvar Range = function () {\n  function Range() {\n    _classCallCheck(this, Range);\n    this._left = [];\n    this._right = [];\n  }\n  _createClass(Range, [{\n    key: \"left\",\n    value: function left(value) {\n      var exclusive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      this._left.push([value, exclusive]);\n    }\n  }, {\n    key: \"right\",\n    value: function right(value) {\n      var exclusive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      this._right.push([value, exclusive]);\n    }\n  }, {\n    key: \"format\",\n    value: function format() {\n      var logic = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      var _Range$getRangeValue = Range.getRangeValue(this._left, logic),\n        _Range$getRangeValue2 = _slicedToArray(_Range$getRangeValue, 2),\n        start = _Range$getRangeValue2[0],\n        leftExclusive = _Range$getRangeValue2[1];\n      var _Range$getRangeValue3 = Range.getRangeValue(this._right, !logic),\n        _Range$getRangeValue4 = _slicedToArray(_Range$getRangeValue3, 2),\n        end = _Range$getRangeValue4[0],\n        rightExclusive = _Range$getRangeValue4[1];\n      if (!Number.isFinite(start) && !Number.isFinite(end)) {\n        return '';\n      }\n      var realStart = leftExclusive ? start + 1 : start;\n      var realEnd = rightExclusive ? end - 1 : end;\n      if (realStart === realEnd) {\n        return \"should be \" + (logic ? '' : '!') + \"= \" + realStart;\n      }\n      if (Number.isFinite(start) && !Number.isFinite(end)) {\n        return Range.formatLeft(start, logic, leftExclusive);\n      }\n      if (!Number.isFinite(start) && Number.isFinite(end)) {\n        return Range.formatRight(end, logic, rightExclusive);\n      }\n      return Range.formatRange(start, end, leftExclusive, rightExclusive, logic);\n    }\n  }], [{\n    key: \"getOperator\",\n    value: function getOperator(side, exclusive) {\n      if (side === 'left') {\n        return exclusive ? '>' : '>=';\n      }\n      return exclusive ? '<' : '<=';\n    }\n  }, {\n    key: \"formatRight\",\n    value: function formatRight(value, logic, exclusive) {\n      if (logic === false) {\n        return Range.formatLeft(value, !logic, !exclusive);\n      }\n      return \"should be \" + Range.getOperator('right', exclusive) + \" \" + value;\n    }\n  }, {\n    key: \"formatLeft\",\n    value: function formatLeft(value, logic, exclusive) {\n      if (logic === false) {\n        return Range.formatRight(value, !logic, !exclusive);\n      }\n      return \"should be \" + Range.getOperator('left', exclusive) + \" \" + value;\n    }\n  }, {\n    key: \"formatRange\",\n    value: function formatRange(start, end, startExclusive, endExclusive, logic) {\n      var result = 'should be';\n      result += \" \" + Range.getOperator(logic ? 'left' : 'right', logic ? startExclusive : !startExclusive) + \" \" + start + \" \";\n      result += logic ? 'and' : 'or';\n      result += \" \" + Range.getOperator(logic ? 'right' : 'left', logic ? endExclusive : !endExclusive) + \" \" + end;\n      return result;\n    }\n  }, {\n    key: \"getRangeValue\",\n    value: function getRangeValue(values, logic) {\n      var minMax = logic ? Infinity : -Infinity;\n      var j = -1;\n      var predicate = logic ? function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 1),\n          value = _ref2[0];\n        return value <= minMax;\n      } : function (_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 1),\n          value = _ref4[0];\n        return value >= minMax;\n      };\n      for (var i = 0; i < values.length; i++) {\n        if (predicate(values[i])) {\n          var _values$i = _slicedToArray(values[i], 1);\n          minMax = _values$i[0];\n          j = i;\n        }\n      }\n      if (j > -1) {\n        return values[j];\n      }\n      return [Infinity, true];\n    }\n  }]);\n  return Range;\n}();\nmodule.exports = Range;","map":{"version":3,"names":["_slicedToArray","require","_classCallCheck","_createClass","Range","_left","_right","key","value","left","exclusive","arguments","length","undefined","push","right","format","logic","_Range$getRangeValue","getRangeValue","_Range$getRangeValue2","start","leftExclusive","_Range$getRangeValue3","_Range$getRangeValue4","end","rightExclusive","Number","isFinite","realStart","realEnd","formatLeft","formatRight","formatRange","getOperator","side","startExclusive","endExclusive","result","values","minMax","Infinity","j","predicate","_ref","_ref2","_ref3","_ref4","i","_values$i","module","exports"],"sources":["/Users/henriqueeidt/Documents/Projects/poc-web-mobile-components/component-library/node_modules/@expo/webpack-config/node_modules/schema-utils/dist/util/Range.js"],"sourcesContent":["\"use strict\";\n\n/**\n * @typedef {[number, boolean]} RangeValue\n */\n\n/**\n * @callback RangeValueCallback\n * @param {RangeValue} rangeValue\n * @returns {boolean}\n */\nclass Range {\n  /**\n   * @param {\"left\" | \"right\"} side\n   * @param {boolean} exclusive\n   * @returns {\">\" | \">=\" | \"<\" | \"<=\"}\n   */\n  static getOperator(side, exclusive) {\n    if (side === 'left') {\n      return exclusive ? '>' : '>=';\n    }\n\n    return exclusive ? '<' : '<=';\n  }\n  /**\n   * @param {number} value\n   * @param {boolean} logic is not logic applied\n   * @param {boolean} exclusive is range exclusive\n   * @returns {string}\n   */\n\n\n  static formatRight(value, logic, exclusive) {\n    if (logic === false) {\n      return Range.formatLeft(value, !logic, !exclusive);\n    }\n\n    return `should be ${Range.getOperator('right', exclusive)} ${value}`;\n  }\n  /**\n   * @param {number} value\n   * @param {boolean} logic is not logic applied\n   * @param {boolean} exclusive is range exclusive\n   * @returns {string}\n   */\n\n\n  static formatLeft(value, logic, exclusive) {\n    if (logic === false) {\n      return Range.formatRight(value, !logic, !exclusive);\n    }\n\n    return `should be ${Range.getOperator('left', exclusive)} ${value}`;\n  }\n  /**\n   * @param {number} start left side value\n   * @param {number} end right side value\n   * @param {boolean} startExclusive is range exclusive from left side\n   * @param {boolean} endExclusive is range exclusive from right side\n   * @param {boolean} logic is not logic applied\n   * @returns {string}\n   */\n\n\n  static formatRange(start, end, startExclusive, endExclusive, logic) {\n    let result = 'should be';\n    result += ` ${Range.getOperator(logic ? 'left' : 'right', logic ? startExclusive : !startExclusive)} ${start} `;\n    result += logic ? 'and' : 'or';\n    result += ` ${Range.getOperator(logic ? 'right' : 'left', logic ? endExclusive : !endExclusive)} ${end}`;\n    return result;\n  }\n  /**\n   * @param {Array<RangeValue>} values\n   * @param {boolean} logic is not logic applied\n   * @return {RangeValue} computed value and it's exclusive flag\n   */\n\n\n  static getRangeValue(values, logic) {\n    let minMax = logic ? Infinity : -Infinity;\n    let j = -1;\n    const predicate = logic ?\n    /** @type {RangeValueCallback} */\n    ([value]) => value <= minMax :\n    /** @type {RangeValueCallback} */\n    ([value]) => value >= minMax;\n\n    for (let i = 0; i < values.length; i++) {\n      if (predicate(values[i])) {\n        [minMax] = values[i];\n        j = i;\n      }\n    }\n\n    if (j > -1) {\n      return values[j];\n    }\n\n    return [Infinity, true];\n  }\n\n  constructor() {\n    /** @type {Array<RangeValue>} */\n    this._left = [];\n    /** @type {Array<RangeValue>} */\n\n    this._right = [];\n  }\n  /**\n   * @param {number} value\n   * @param {boolean=} exclusive\n   */\n\n\n  left(value, exclusive = false) {\n    this._left.push([value, exclusive]);\n  }\n  /**\n   * @param {number} value\n   * @param {boolean=} exclusive\n   */\n\n\n  right(value, exclusive = false) {\n    this._right.push([value, exclusive]);\n  }\n  /**\n   * @param {boolean} logic is not logic applied\n   * @return {string} \"smart\" range string representation\n   */\n\n\n  format(logic = true) {\n    const [start, leftExclusive] = Range.getRangeValue(this._left, logic);\n    const [end, rightExclusive] = Range.getRangeValue(this._right, !logic);\n\n    if (!Number.isFinite(start) && !Number.isFinite(end)) {\n      return '';\n    }\n\n    const realStart = leftExclusive ? start + 1 : start;\n    const realEnd = rightExclusive ? end - 1 : end; // e.g. 5 < x < 7, 5 < x <= 6, 6 <= x <= 6\n\n    if (realStart === realEnd) {\n      return `should be ${logic ? '' : '!'}= ${realStart}`;\n    } // e.g. 4 < x < ∞\n\n\n    if (Number.isFinite(start) && !Number.isFinite(end)) {\n      return Range.formatLeft(start, logic, leftExclusive);\n    } // e.g. ∞ < x < 4\n\n\n    if (!Number.isFinite(start) && Number.isFinite(end)) {\n      return Range.formatRight(end, logic, rightExclusive);\n    }\n\n    return Range.formatRange(start, end, leftExclusive, rightExclusive, logic);\n  }\n\n}\n\nmodule.exports = Range;"],"mappings":"AAAA,YAAY;AAAC,IAAAA,cAAA,GAAAC,OAAA;AAAA,IAAAC,eAAA,GAAAD,OAAA;AAAA,IAAAE,YAAA,GAAAF,OAAA;AAAA,IAWPG,KAAK;EA0FT,SAAAA,MAAA,EAAc;IAAAF,eAAA,OAAAE,KAAA;IAEZ,IAAI,CAACC,KAAK,GAAG,EAAE;IAGf,IAAI,CAACC,MAAM,GAAG,EAAE;EAClB;EAACH,YAAA,CAAAC,KAAA;IAAAG,GAAA;IAAAC,KAAA,EAOD,SAAAC,KAAKD,KAAK,EAAqB;MAAA,IAAnBE,SAAS,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,KAAK;MAC3B,IAAI,CAACN,KAAK,CAACS,IAAI,CAAC,CAACN,KAAK,EAAEE,SAAS,CAAC,CAAC;IACrC;EAAC;IAAAH,GAAA;IAAAC,KAAA,EAOD,SAAAO,MAAMP,KAAK,EAAqB;MAAA,IAAnBE,SAAS,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,KAAK;MAC5B,IAAI,CAACL,MAAM,CAACQ,IAAI,CAAC,CAACN,KAAK,EAAEE,SAAS,CAAC,CAAC;IACtC;EAAC;IAAAH,GAAA;IAAAC,KAAA,EAOD,SAAAQ,OAAA,EAAqB;MAAA,IAAdC,KAAK,GAAAN,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,IAAI;MACjB,IAAAO,oBAAA,GAA+Bd,KAAK,CAACe,aAAa,CAAC,IAAI,CAACd,KAAK,EAAEY,KAAK,CAAC;QAAAG,qBAAA,GAAApB,cAAA,CAAAkB,oBAAA;QAA9DG,KAAK,GAAAD,qBAAA;QAAEE,aAAa,GAAAF,qBAAA;MAC3B,IAAAG,qBAAA,GAA8BnB,KAAK,CAACe,aAAa,CAAC,IAAI,CAACb,MAAM,EAAE,CAACW,KAAK,CAAC;QAAAO,qBAAA,GAAAxB,cAAA,CAAAuB,qBAAA;QAA/DE,GAAG,GAAAD,qBAAA;QAAEE,cAAc,GAAAF,qBAAA;MAE1B,IAAI,CAACG,MAAM,CAACC,QAAQ,CAACP,KAAK,CAAC,IAAI,CAACM,MAAM,CAACC,QAAQ,CAACH,GAAG,CAAC,EAAE;QACpD,OAAO,EAAE;MACX;MAEA,IAAMI,SAAS,GAAGP,aAAa,GAAGD,KAAK,GAAG,CAAC,GAAGA,KAAK;MACnD,IAAMS,OAAO,GAAGJ,cAAc,GAAGD,GAAG,GAAG,CAAC,GAAGA,GAAG;MAE9C,IAAII,SAAS,KAAKC,OAAO,EAAE;QACzB,uBAAoBb,KAAK,GAAG,EAAE,GAAG,GAAG,WAAKY,SAAS;MACpD;MAGA,IAAIF,MAAM,CAACC,QAAQ,CAACP,KAAK,CAAC,IAAI,CAACM,MAAM,CAACC,QAAQ,CAACH,GAAG,CAAC,EAAE;QACnD,OAAOrB,KAAK,CAAC2B,UAAU,CAACV,KAAK,EAAEJ,KAAK,EAAEK,aAAa,CAAC;MACtD;MAGA,IAAI,CAACK,MAAM,CAACC,QAAQ,CAACP,KAAK,CAAC,IAAIM,MAAM,CAACC,QAAQ,CAACH,GAAG,CAAC,EAAE;QACnD,OAAOrB,KAAK,CAAC4B,WAAW,CAACP,GAAG,EAAER,KAAK,EAAES,cAAc,CAAC;MACtD;MAEA,OAAOtB,KAAK,CAAC6B,WAAW,CAACZ,KAAK,EAAEI,GAAG,EAAEH,aAAa,EAAEI,cAAc,EAAET,KAAK,CAAC;IAC5E;EAAC;IAAAV,GAAA;IAAAC,KAAA,EA7ID,SAAA0B,YAAmBC,IAAI,EAAEzB,SAAS,EAAE;MAClC,IAAIyB,IAAI,KAAK,MAAM,EAAE;QACnB,OAAOzB,SAAS,GAAG,GAAG,GAAG,IAAI;MAC/B;MAEA,OAAOA,SAAS,GAAG,GAAG,GAAG,IAAI;IAC/B;EAAC;IAAAH,GAAA;IAAAC,KAAA,EASD,SAAAwB,YAAmBxB,KAAK,EAAES,KAAK,EAAEP,SAAS,EAAE;MAC1C,IAAIO,KAAK,KAAK,KAAK,EAAE;QACnB,OAAOb,KAAK,CAAC2B,UAAU,CAACvB,KAAK,EAAE,CAACS,KAAK,EAAE,CAACP,SAAS,CAAC;MACpD;MAEA,sBAAoBN,KAAK,CAAC8B,WAAW,CAAC,OAAO,EAAExB,SAAS,CAAC,SAAIF,KAAK;IACpE;EAAC;IAAAD,GAAA;IAAAC,KAAA,EASD,SAAAuB,WAAkBvB,KAAK,EAAES,KAAK,EAAEP,SAAS,EAAE;MACzC,IAAIO,KAAK,KAAK,KAAK,EAAE;QACnB,OAAOb,KAAK,CAAC4B,WAAW,CAACxB,KAAK,EAAE,CAACS,KAAK,EAAE,CAACP,SAAS,CAAC;MACrD;MAEA,sBAAoBN,KAAK,CAAC8B,WAAW,CAAC,MAAM,EAAExB,SAAS,CAAC,SAAIF,KAAK;IACnE;EAAC;IAAAD,GAAA;IAAAC,KAAA,EAWD,SAAAyB,YAAmBZ,KAAK,EAAEI,GAAG,EAAEW,cAAc,EAAEC,YAAY,EAAEpB,KAAK,EAAE;MAClE,IAAIqB,MAAM,GAAG,WAAW;MACxBA,MAAM,UAAQlC,KAAK,CAAC8B,WAAW,CAACjB,KAAK,GAAG,MAAM,GAAG,OAAO,EAAEA,KAAK,GAAGmB,cAAc,GAAG,CAACA,cAAc,CAAC,SAAIf,KAAK,MAAG;MAC/GiB,MAAM,IAAIrB,KAAK,GAAG,KAAK,GAAG,IAAI;MAC9BqB,MAAM,UAAQlC,KAAK,CAAC8B,WAAW,CAACjB,KAAK,GAAG,OAAO,GAAG,MAAM,EAAEA,KAAK,GAAGoB,YAAY,GAAG,CAACA,YAAY,CAAC,SAAIZ,GAAK;MACxG,OAAOa,MAAM;IACf;EAAC;IAAA/B,GAAA;IAAAC,KAAA,EAQD,SAAAW,cAAqBoB,MAAM,EAAEtB,KAAK,EAAE;MAClC,IAAIuB,MAAM,GAAGvB,KAAK,GAAGwB,QAAQ,GAAG,CAACA,QAAQ;MACzC,IAAIC,CAAC,GAAG,CAAC,CAAC;MACV,IAAMC,SAAS,GAAG1B,KAAK,GAEvB,UAAA2B,IAAA;QAAA,IAAAC,KAAA,GAAA7C,cAAA,CAAA4C,IAAA;UAAEpC,KAAK,GAAAqC,KAAA;QAAA,OAAMrC,KAAK,IAAIgC,MAAM;MAAA,IAE5B,UAAAM,KAAA;QAAA,IAAAC,KAAA,GAAA/C,cAAA,CAAA8C,KAAA;UAAEtC,KAAK,GAAAuC,KAAA;QAAA,OAAMvC,KAAK,IAAIgC,MAAM;MAAA;MAE5B,KAAK,IAAIQ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGT,MAAM,CAAC3B,MAAM,EAAEoC,CAAC,EAAE,EAAE;QACtC,IAAIL,SAAS,CAACJ,MAAM,CAACS,CAAC,CAAC,CAAC,EAAE;UAAA,IAAAC,SAAA,GAAAjD,cAAA,CACbuC,MAAM,CAACS,CAAC,CAAC;UAAnBR,MAAM,GAAAS,SAAA;UACPP,CAAC,GAAGM,CAAC;QACP;MACF;MAEA,IAAIN,CAAC,GAAG,CAAC,CAAC,EAAE;QACV,OAAOH,MAAM,CAACG,CAAC,CAAC;MAClB;MAEA,OAAO,CAACD,QAAQ,EAAE,IAAI,CAAC;IACzB;EAAC;EAAA,OAAArC,KAAA;AAAA;AA+DH8C,MAAM,CAACC,OAAO,GAAG/C,KAAK"},"metadata":{},"sourceType":"script","externalDependencies":[]}
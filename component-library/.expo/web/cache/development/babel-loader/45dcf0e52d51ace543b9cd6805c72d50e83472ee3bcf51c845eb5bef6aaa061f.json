{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\nvar fs = require(\"../fs\");\nvar path = require('path');\nvar util = require('util');\nvar atLeastNode = require('at-least-node');\nvar nodeSupportsBigInt = atLeastNode('10.5.0');\nvar stat = function stat(file) {\n  return nodeSupportsBigInt ? fs.stat(file, {\n    bigint: true\n  }) : fs.stat(file);\n};\nvar statSync = function statSync(file) {\n  return nodeSupportsBigInt ? fs.statSync(file, {\n    bigint: true\n  }) : fs.statSync(file);\n};\nfunction getStats(src, dest) {\n  return Promise.all([stat(src), stat(dest).catch(function (err) {\n    if (err.code === 'ENOENT') return null;\n    throw err;\n  })]).then(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n      srcStat = _ref2[0],\n      destStat = _ref2[1];\n    return {\n      srcStat: srcStat,\n      destStat: destStat\n    };\n  });\n}\nfunction getStatsSync(src, dest) {\n  var destStat;\n  var srcStat = statSync(src);\n  try {\n    destStat = statSync(dest);\n  } catch (err) {\n    if (err.code === 'ENOENT') return {\n      srcStat: srcStat,\n      destStat: null\n    };\n    throw err;\n  }\n  return {\n    srcStat: srcStat,\n    destStat: destStat\n  };\n}\nfunction checkPaths(src, dest, funcName, cb) {\n  util.callbackify(getStats)(src, dest, function (err, stats) {\n    if (err) return cb(err);\n    var srcStat = stats.srcStat,\n      destStat = stats.destStat;\n    if (destStat && areIdentical(srcStat, destStat)) {\n      return cb(new Error('Source and destination must not be the same.'));\n    }\n    if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n      return cb(new Error(errMsg(src, dest, funcName)));\n    }\n    return cb(null, {\n      srcStat: srcStat,\n      destStat: destStat\n    });\n  });\n}\nfunction checkPathsSync(src, dest, funcName) {\n  var _getStatsSync = getStatsSync(src, dest),\n    srcStat = _getStatsSync.srcStat,\n    destStat = _getStatsSync.destStat;\n  if (destStat && areIdentical(srcStat, destStat)) {\n    throw new Error('Source and destination must not be the same.');\n  }\n  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n    throw new Error(errMsg(src, dest, funcName));\n  }\n  return {\n    srcStat: srcStat,\n    destStat: destStat\n  };\n}\nfunction checkParentPaths(src, srcStat, dest, funcName, cb) {\n  var srcParent = path.resolve(path.dirname(src));\n  var destParent = path.resolve(path.dirname(dest));\n  if (destParent === srcParent || destParent === path.parse(destParent).root) return cb();\n  var callback = function callback(err, destStat) {\n    if (err) {\n      if (err.code === 'ENOENT') return cb();\n      return cb(err);\n    }\n    if (areIdentical(srcStat, destStat)) {\n      return cb(new Error(errMsg(src, dest, funcName)));\n    }\n    return checkParentPaths(src, srcStat, destParent, funcName, cb);\n  };\n  if (nodeSupportsBigInt) fs.stat(destParent, {\n    bigint: true\n  }, callback);else fs.stat(destParent, callback);\n}\nfunction checkParentPathsSync(src, srcStat, dest, funcName) {\n  var srcParent = path.resolve(path.dirname(src));\n  var destParent = path.resolve(path.dirname(dest));\n  if (destParent === srcParent || destParent === path.parse(destParent).root) return;\n  var destStat;\n  try {\n    destStat = statSync(destParent);\n  } catch (err) {\n    if (err.code === 'ENOENT') return;\n    throw err;\n  }\n  if (areIdentical(srcStat, destStat)) {\n    throw new Error(errMsg(src, dest, funcName));\n  }\n  return checkParentPathsSync(src, srcStat, destParent, funcName);\n}\nfunction areIdentical(srcStat, destStat) {\n  if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {\n    if (nodeSupportsBigInt || destStat.ino < Number.MAX_SAFE_INTEGER) {\n      return true;\n    }\n    if (destStat.size === srcStat.size && destStat.mode === srcStat.mode && destStat.nlink === srcStat.nlink && destStat.atimeMs === srcStat.atimeMs && destStat.mtimeMs === srcStat.mtimeMs && destStat.ctimeMs === srcStat.ctimeMs && destStat.birthtimeMs === srcStat.birthtimeMs) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction isSrcSubdir(src, dest) {\n  var srcArr = path.resolve(src).split(path.sep).filter(function (i) {\n    return i;\n  });\n  var destArr = path.resolve(dest).split(path.sep).filter(function (i) {\n    return i;\n  });\n  return srcArr.reduce(function (acc, cur, i) {\n    return acc && destArr[i] === cur;\n  }, true);\n}\nfunction errMsg(src, dest, funcName) {\n  return \"Cannot \" + funcName + \" '\" + src + \"' to a subdirectory of itself, '\" + dest + \"'.\";\n}\nmodule.exports = {\n  checkPaths: checkPaths,\n  checkPathsSync: checkPathsSync,\n  checkParentPaths: checkParentPaths,\n  checkParentPathsSync: checkParentPathsSync,\n  isSrcSubdir: isSrcSubdir\n};","map":{"version":3,"names":["_slicedToArray","require","fs","path","util","atLeastNode","nodeSupportsBigInt","stat","file","bigint","statSync","getStats","src","dest","Promise","all","catch","err","code","then","_ref","_ref2","srcStat","destStat","getStatsSync","checkPaths","funcName","cb","callbackify","stats","areIdentical","Error","isDirectory","isSrcSubdir","errMsg","checkPathsSync","_getStatsSync","checkParentPaths","srcParent","resolve","dirname","destParent","parse","root","callback","checkParentPathsSync","ino","dev","Number","MAX_SAFE_INTEGER","size","mode","nlink","atimeMs","mtimeMs","ctimeMs","birthtimeMs","srcArr","split","sep","filter","i","destArr","reduce","acc","cur","module","exports"],"sources":["/Users/henriqueeidt/Documents/Projects/poc-web-mobile-components/component-library/node_modules/expo-pwa/node_modules/fs-extra/lib/util/stat.js"],"sourcesContent":["'use strict'\n\nconst fs = require('../fs')\nconst path = require('path')\nconst util = require('util')\nconst atLeastNode = require('at-least-node')\n\nconst nodeSupportsBigInt = atLeastNode('10.5.0')\nconst stat = (file) => nodeSupportsBigInt ? fs.stat(file, { bigint: true }) : fs.stat(file)\nconst statSync = (file) => nodeSupportsBigInt ? fs.statSync(file, { bigint: true }) : fs.statSync(file)\n\nfunction getStats (src, dest) {\n  return Promise.all([\n    stat(src),\n    stat(dest).catch(err => {\n      if (err.code === 'ENOENT') return null\n      throw err\n    })\n  ]).then(([srcStat, destStat]) => ({ srcStat, destStat }))\n}\n\nfunction getStatsSync (src, dest) {\n  let destStat\n  const srcStat = statSync(src)\n  try {\n    destStat = statSync(dest)\n  } catch (err) {\n    if (err.code === 'ENOENT') return { srcStat, destStat: null }\n    throw err\n  }\n  return { srcStat, destStat }\n}\n\nfunction checkPaths (src, dest, funcName, cb) {\n  util.callbackify(getStats)(src, dest, (err, stats) => {\n    if (err) return cb(err)\n    const { srcStat, destStat } = stats\n    if (destStat && areIdentical(srcStat, destStat)) {\n      return cb(new Error('Source and destination must not be the same.'))\n    }\n    if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n      return cb(new Error(errMsg(src, dest, funcName)))\n    }\n    return cb(null, { srcStat, destStat })\n  })\n}\n\nfunction checkPathsSync (src, dest, funcName) {\n  const { srcStat, destStat } = getStatsSync(src, dest)\n  if (destStat && areIdentical(srcStat, destStat)) {\n    throw new Error('Source and destination must not be the same.')\n  }\n  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n    throw new Error(errMsg(src, dest, funcName))\n  }\n  return { srcStat, destStat }\n}\n\n// recursively check if dest parent is a subdirectory of src.\n// It works for all file types including symlinks since it\n// checks the src and dest inodes. It starts from the deepest\n// parent and stops once it reaches the src parent or the root path.\nfunction checkParentPaths (src, srcStat, dest, funcName, cb) {\n  const srcParent = path.resolve(path.dirname(src))\n  const destParent = path.resolve(path.dirname(dest))\n  if (destParent === srcParent || destParent === path.parse(destParent).root) return cb()\n  const callback = (err, destStat) => {\n    if (err) {\n      if (err.code === 'ENOENT') return cb()\n      return cb(err)\n    }\n    if (areIdentical(srcStat, destStat)) {\n      return cb(new Error(errMsg(src, dest, funcName)))\n    }\n    return checkParentPaths(src, srcStat, destParent, funcName, cb)\n  }\n  if (nodeSupportsBigInt) fs.stat(destParent, { bigint: true }, callback)\n  else fs.stat(destParent, callback)\n}\n\nfunction checkParentPathsSync (src, srcStat, dest, funcName) {\n  const srcParent = path.resolve(path.dirname(src))\n  const destParent = path.resolve(path.dirname(dest))\n  if (destParent === srcParent || destParent === path.parse(destParent).root) return\n  let destStat\n  try {\n    destStat = statSync(destParent)\n  } catch (err) {\n    if (err.code === 'ENOENT') return\n    throw err\n  }\n  if (areIdentical(srcStat, destStat)) {\n    throw new Error(errMsg(src, dest, funcName))\n  }\n  return checkParentPathsSync(src, srcStat, destParent, funcName)\n}\n\nfunction areIdentical (srcStat, destStat) {\n  if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {\n    if (nodeSupportsBigInt || destStat.ino < Number.MAX_SAFE_INTEGER) {\n      // definitive answer\n      return true\n    }\n    // Use additional heuristics if we can't use 'bigint'.\n    // Different 'ino' could be represented the same if they are >= Number.MAX_SAFE_INTEGER\n    // See issue 657\n    if (destStat.size === srcStat.size &&\n        destStat.mode === srcStat.mode &&\n        destStat.nlink === srcStat.nlink &&\n        destStat.atimeMs === srcStat.atimeMs &&\n        destStat.mtimeMs === srcStat.mtimeMs &&\n        destStat.ctimeMs === srcStat.ctimeMs &&\n        destStat.birthtimeMs === srcStat.birthtimeMs) {\n      // heuristic answer\n      return true\n    }\n  }\n  return false\n}\n\n// return true if dest is a subdir of src, otherwise false.\n// It only checks the path strings.\nfunction isSrcSubdir (src, dest) {\n  const srcArr = path.resolve(src).split(path.sep).filter(i => i)\n  const destArr = path.resolve(dest).split(path.sep).filter(i => i)\n  return srcArr.reduce((acc, cur, i) => acc && destArr[i] === cur, true)\n}\n\nfunction errMsg (src, dest, funcName) {\n  return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`\n}\n\nmodule.exports = {\n  checkPaths,\n  checkPathsSync,\n  checkParentPaths,\n  checkParentPathsSync,\n  isSrcSubdir\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}
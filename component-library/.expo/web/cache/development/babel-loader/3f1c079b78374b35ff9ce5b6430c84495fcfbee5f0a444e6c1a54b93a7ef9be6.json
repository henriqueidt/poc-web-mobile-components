{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.evalConfig = evalConfig;\nexports.resolveConfigExport = resolveConfigExport;\nfunction _fs() {\n  var data = require(\"fs\");\n  _fs = function _fs() {\n    return data;\n  };\n  return data;\n}\nfunction _requireFromString() {\n  var data = _interopRequireDefault(require(\"require-from-string\"));\n  _requireFromString = function _requireFromString() {\n    return data;\n  };\n  return data;\n}\nfunction _sucrase() {\n  var data = require(\"sucrase\");\n  _sucrase = function _sucrase() {\n    return data;\n  };\n  return data;\n}\nfunction _Errors() {\n  var data = require(\"./Errors\");\n  _Errors = function _Errors() {\n    return data;\n  };\n  return data;\n}\nfunction _Serialize() {\n  var data = require(\"./Serialize\");\n  _Serialize = function _Serialize() {\n    return data;\n  };\n  return data;\n}\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction evalConfig(configFile, request) {\n  var contents = (0, _fs().readFileSync)(configFile, 'utf8');\n  var result;\n  try {\n    var _ref = (0, _sucrase().transform)(contents, {\n        filePath: configFile,\n        transforms: ['typescript', 'imports']\n      }),\n      code = _ref.code;\n    result = (0, _requireFromString().default)(code, configFile);\n  } catch (error) {\n    var location = extractLocationFromSyntaxError(error);\n    if (location) {\n      var _require = require('@babel/code-frame'),\n        codeFrameColumns = _require.codeFrameColumns;\n      var codeFrame = codeFrameColumns(contents, {\n        start: error.loc\n      }, {\n        highlightCode: true\n      });\n      error.codeFrame = codeFrame;\n      error.message += \"\\n\" + codeFrame;\n    } else {\n      var importantStack = extractImportantStackFromNodeError(error);\n      if (importantStack) {\n        error.message += \"\\n\" + importantStack;\n      }\n    }\n    throw error;\n  }\n  return resolveConfigExport(result, configFile, request);\n}\nfunction extractLocationFromSyntaxError(error) {\n  if (error.loc) {\n    return error.loc;\n  }\n  if ('lineNumber' in error && 'columnNumber' in error) {\n    return {\n      line: error.lineNumber,\n      column: error.columnNumber\n    };\n  }\n  return null;\n}\nfunction extractImportantStackFromNodeError(error) {\n  if (isSyntaxError(error)) {\n    var _error$stack;\n    var traces = (_error$stack = error.stack) === null || _error$stack === void 0 ? void 0 : _error$stack.split('\\n').filter(function (line) {\n      return !line.startsWith('    at ');\n    });\n    if (!traces) return null;\n    if (traces[traces.length - 1].startsWith('SyntaxError:')) {\n      traces.pop();\n    }\n    return traces.join('\\n');\n  }\n  return null;\n}\nfunction isSyntaxError(error) {\n  return error instanceof SyntaxError || error.constructor.name === 'SyntaxError';\n}\nfunction resolveConfigExport(result, configFile, request) {\n  var _result;\n  if (result.default != null) {\n    result = result.default;\n  }\n  var exportedObjectType = typeof result;\n  if (typeof result === 'function') {\n    result = result(request);\n  }\n  if (result instanceof Promise) {\n    throw new (_Errors().ConfigError)(\"Config file \" + configFile + \" cannot return a Promise.\", 'INVALID_CONFIG');\n  }\n  if ((_result = result) !== null && _result !== void 0 && _result.expo) {\n    result = (0, _Serialize().serializeSkippingMods)(result.expo);\n  } else {\n    result = (0, _Serialize().serializeSkippingMods)(result);\n  }\n  return {\n    config: result,\n    exportedObjectType: exportedObjectType\n  };\n}","map":{"version":3,"names":["_fs","data","require","_requireFromString","_interopRequireDefault","_sucrase","_Errors","_Serialize","evalConfig","configFile","request","contents","readFileSync","result","_ref","transform","filePath","transforms","code","default","error","location","extractLocationFromSyntaxError","_require","codeFrameColumns","codeFrame","start","loc","highlightCode","message","importantStack","extractImportantStackFromNodeError","resolveConfigExport","line","lineNumber","column","columnNumber","isSyntaxError","_error$stack","traces","stack","split","filter","startsWith","length","pop","join","SyntaxError","constructor","name","_result","exportedObjectType","Promise","ConfigError","expo","serializeSkippingMods","config"],"sources":["/Users/henriqueeidt/Documents/Projects/poc-web-mobile-components/component-library/node_modules/@expo/config/src/evalConfig.ts"],"sourcesContent":["import { readFileSync } from 'fs';\nimport requireString from 'require-from-string';\nimport { transform } from 'sucrase';\n\nimport { AppJSONConfig, ConfigContext, ExpoConfig } from './Config.types';\nimport { ConfigError } from './Errors';\nimport { serializeSkippingMods } from './Serialize';\n\ntype RawDynamicConfig = AppJSONConfig | Partial<ExpoConfig> | null;\n\nexport type DynamicConfigResults = { config: RawDynamicConfig; exportedObjectType: string };\n\n/**\n * Transpile and evaluate the dynamic config object.\n * This method is shared between the standard reading method in getConfig, and the headless script.\n *\n * @param options configFile path to the dynamic app.config.*, request to send to the dynamic config if it exports a function.\n * @returns the serialized and evaluated config along with the exported object type (object or function).\n */\nexport function evalConfig(\n  configFile: string,\n  request: ConfigContext | null\n): DynamicConfigResults {\n  const contents = readFileSync(configFile, 'utf8');\n  let result: any;\n  try {\n    const { code } = transform(contents, {\n      filePath: configFile,\n      transforms: ['typescript', 'imports'],\n    });\n\n    result = requireString(code, configFile);\n  } catch (error) {\n    const location = extractLocationFromSyntaxError(error);\n\n    // Apply a code frame preview to the error if possible, sucrase doesn't do this by default.\n    if (location) {\n      const { codeFrameColumns } = require('@babel/code-frame');\n      const codeFrame = codeFrameColumns(contents, { start: error.loc }, { highlightCode: true });\n      error.codeFrame = codeFrame;\n      error.message += `\\n${codeFrame}`;\n    } else {\n      const importantStack = extractImportantStackFromNodeError(error);\n\n      if (importantStack) {\n        error.message += `\\n${importantStack}`;\n      }\n    }\n    throw error;\n  }\n  return resolveConfigExport(result, configFile, request);\n}\n\nfunction extractLocationFromSyntaxError(\n  error: Error | any\n): { line: number; column?: number } | null {\n  // sucrase provides the `loc` object\n  if (error.loc) {\n    return error.loc;\n  }\n\n  // `SyntaxError`s provide the `lineNumber` and `columnNumber` properties\n  if ('lineNumber' in error && 'columnNumber' in error) {\n    return { line: error.lineNumber, column: error.columnNumber };\n  }\n\n  return null;\n}\n\n// These kinda errors often come from syntax errors in files that were imported by the main file.\n// An example is a module that includes an import statement.\nfunction extractImportantStackFromNodeError(error: any): string | null {\n  if (isSyntaxError(error)) {\n    const traces = error.stack?.split('\\n').filter(line => !line.startsWith('    at '));\n    if (!traces) return null;\n\n    // Remove redundant line\n    if (traces[traces.length - 1].startsWith('SyntaxError:')) {\n      traces.pop();\n    }\n    return traces.join('\\n');\n  }\n  return null;\n}\n\nfunction isSyntaxError(error: any): error is SyntaxError {\n  return error instanceof SyntaxError || error.constructor.name === 'SyntaxError';\n}\n\n/**\n * - Resolve the exported contents of an Expo config (be it default or module.exports)\n * - Assert no promise exports\n * - Return config type\n * - Serialize config\n *\n * @param result\n * @param configFile\n * @param request\n */\nexport function resolveConfigExport(\n  result: any,\n  configFile: string,\n  request: ConfigContext | null\n) {\n  if (result.default != null) {\n    result = result.default;\n  }\n  const exportedObjectType = typeof result;\n  if (typeof result === 'function') {\n    result = result(request);\n  }\n\n  if (result instanceof Promise) {\n    throw new ConfigError(`Config file ${configFile} cannot return a Promise.`, 'INVALID_CONFIG');\n  }\n\n  // If the expo object exists, ignore all other values.\n  if (result?.expo) {\n    result = serializeSkippingMods(result.expo);\n  } else {\n    result = serializeSkippingMods(result);\n  }\n\n  return { config: result, exportedObjectType };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}
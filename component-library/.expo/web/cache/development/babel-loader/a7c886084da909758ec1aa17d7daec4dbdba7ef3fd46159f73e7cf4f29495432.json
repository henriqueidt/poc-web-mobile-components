{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"@babel/runtime/helpers/asyncToGenerator\");\nvar _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\nvar _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\nvar _objectWithoutProperties = require(\"@babel/runtime/helpers/objectWithoutProperties\");\nvar _excluded = [\"mods\"];\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar _exportNames = {\n  getConfig: true,\n  getPackageJson: true,\n  readConfigJson: true,\n  getConfigFilePaths: true,\n  findConfigFile: true,\n  configFilename: true,\n  readExpRcAsync: true,\n  resetCustomConfigPaths: true,\n  setCustomConfigPath: true,\n  modifyConfigAsync: true,\n  writeConfigJsonAsync: true,\n  getWebOutputPath: true,\n  getNameFromConfig: true,\n  getDefaultTarget: true,\n  getProjectConfigDescription: true,\n  getProjectConfigDescriptionWithPaths: true,\n  isLegacyImportsEnabled: true\n};\nexports.configFilename = configFilename;\nexports.findConfigFile = findConfigFile;\nexports.getConfig = getConfig;\nexports.getConfigFilePaths = getConfigFilePaths;\nexports.getDefaultTarget = getDefaultTarget;\nexports.getNameFromConfig = getNameFromConfig;\nexports.getPackageJson = getPackageJson;\nexports.getProjectConfigDescription = getProjectConfigDescription;\nexports.getProjectConfigDescriptionWithPaths = getProjectConfigDescriptionWithPaths;\nexports.getWebOutputPath = getWebOutputPath;\nObject.defineProperty(exports, \"isLegacyImportsEnabled\", {\n  enumerable: true,\n  get: function get() {\n    return _isLegacyImportsEnabled().isLegacyImportsEnabled;\n  }\n});\nexports.modifyConfigAsync = modifyConfigAsync;\nexports.readConfigJson = readConfigJson;\nexports.readExpRcAsync = readExpRcAsync;\nexports.resetCustomConfigPaths = resetCustomConfigPaths;\nexports.setCustomConfigPath = setCustomConfigPath;\nexports.writeConfigJsonAsync = writeConfigJsonAsync;\nfunction _jsonFile() {\n  var data = _interopRequireDefault(require(\"@expo/json-file\"));\n  _jsonFile = function _jsonFile() {\n    return data;\n  };\n  return data;\n}\nfunction _fs() {\n  var data = _interopRequireDefault(require(\"fs\"));\n  _fs = function _fs() {\n    return data;\n  };\n  return data;\n}\nfunction _glob() {\n  var data = require(\"glob\");\n  _glob = function _glob() {\n    return data;\n  };\n  return data;\n}\nfunction _path() {\n  var data = _interopRequireDefault(require(\"path\"));\n  _path = function _path() {\n    return data;\n  };\n  return data;\n}\nfunction _resolveFrom() {\n  var data = _interopRequireDefault(require(\"resolve-from\"));\n  _resolveFrom = function _resolveFrom() {\n    return data;\n  };\n  return data;\n}\nfunction _semver() {\n  var data = _interopRequireDefault(require(\"semver\"));\n  _semver = function _semver() {\n    return data;\n  };\n  return data;\n}\nfunction _slugify() {\n  var data = _interopRequireDefault(require(\"slugify\"));\n  _slugify = function _slugify() {\n    return data;\n  };\n  return data;\n}\nfunction _Errors() {\n  var data = require(\"./Errors\");\n  _Errors = function _Errors() {\n    return data;\n  };\n  return data;\n}\nfunction _Project() {\n  var data = require(\"./Project\");\n  _Project = function _Project() {\n    return data;\n  };\n  return data;\n}\nfunction _getConfig() {\n  var data = require(\"./getConfig\");\n  _getConfig = function _getConfig() {\n    return data;\n  };\n  return data;\n}\nfunction _getFullName() {\n  var data = require(\"./getFullName\");\n  _getFullName = function _getFullName() {\n    return data;\n  };\n  return data;\n}\nfunction _withConfigPlugins() {\n  var data = require(\"./plugins/withConfigPlugins\");\n  _withConfigPlugins = function _withConfigPlugins() {\n    return data;\n  };\n  return data;\n}\nfunction _withInternal() {\n  var data = require(\"./plugins/withInternal\");\n  _withInternal = function _withInternal() {\n    return data;\n  };\n  return data;\n}\nfunction _resolvePackageJson() {\n  var data = require(\"./resolvePackageJson\");\n  _resolvePackageJson = function _resolvePackageJson() {\n    return data;\n  };\n  return data;\n}\nvar _Config = require(\"./Config.types\");\nObject.keys(_Config).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _Config[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _Config[key];\n    }\n  });\n});\nfunction _isLegacyImportsEnabled() {\n  var data = require(\"./isLegacyImportsEnabled\");\n  _isLegacyImportsEnabled = function _isLegacyImportsEnabled() {\n    return data;\n  };\n  return data;\n}\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction reduceExpoObject(config) {\n  var _config$expo;\n  if (!config) return config === undefined ? null : config;\n  var _ref = (_config$expo = config.expo) !== null && _config$expo !== void 0 ? _config$expo : config,\n    mods = _ref.mods,\n    expo = _objectWithoutProperties(_ref, _excluded);\n  return {\n    expo: expo,\n    mods: mods\n  };\n}\nfunction getSupportedPlatforms(projectRoot) {\n  var platforms = [];\n  if (_resolveFrom().default.silent(projectRoot, 'react-native')) {\n    platforms.push('ios', 'android');\n  }\n  if (_resolveFrom().default.silent(projectRoot, 'react-native-web')) {\n    platforms.push('web');\n  }\n  return platforms;\n}\nfunction getConfig(projectRoot) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var paths = getConfigFilePaths(projectRoot);\n  var rawStaticConfig = paths.staticConfigPath ? (0, _getConfig().getStaticConfig)(paths.staticConfigPath) : null;\n  var rootConfig = rawStaticConfig || {};\n  var staticConfig = reduceExpoObject(rawStaticConfig) || {};\n  var _getPackageJsonAndPat = getPackageJsonAndPath(projectRoot),\n    _getPackageJsonAndPat2 = _slicedToArray(_getPackageJsonAndPat, 2),\n    packageJson = _getPackageJsonAndPat2[0],\n    packageJsonPath = _getPackageJsonAndPat2[1];\n  function fillAndReturnConfig(config, dynamicConfigObjectType) {\n    var configWithDefaultValues = _objectSpread(_objectSpread({}, ensureConfigHasDefaultValues({\n      projectRoot: projectRoot,\n      exp: config.expo,\n      pkg: packageJson,\n      skipSDKVersionRequirement: options.skipSDKVersionRequirement,\n      paths: paths,\n      packageJsonPath: packageJsonPath\n    })), {}, {\n      mods: config.mods,\n      dynamicConfigObjectType: dynamicConfigObjectType,\n      rootConfig: rootConfig,\n      dynamicConfigPath: paths.dynamicConfigPath,\n      staticConfigPath: paths.staticConfigPath\n    });\n    if (options.isModdedConfig) {\n      var _config$mods;\n      configWithDefaultValues.exp.mods = (_config$mods = config.mods) !== null && _config$mods !== void 0 ? _config$mods : null;\n    }\n    configWithDefaultValues.exp = (0, _withConfigPlugins().withConfigPlugins)(configWithDefaultValues.exp, !!options.skipPlugins);\n    if (!options.isModdedConfig) {\n      delete configWithDefaultValues.exp.mods;\n    }\n    if (options.isPublicConfig) {\n      var _configWithDefaultVal, _configWithDefaultVal2, _configWithDefaultVal3, _configWithDefaultVal4;\n      delete configWithDefaultValues.exp._internal;\n      if (configWithDefaultValues.exp.hooks) {\n        delete configWithDefaultValues.exp.hooks;\n      }\n      if ((_configWithDefaultVal = configWithDefaultValues.exp.ios) !== null && _configWithDefaultVal !== void 0 && _configWithDefaultVal.config) {\n        delete configWithDefaultValues.exp.ios.config;\n      }\n      if ((_configWithDefaultVal2 = configWithDefaultValues.exp.android) !== null && _configWithDefaultVal2 !== void 0 && _configWithDefaultVal2.config) {\n        delete configWithDefaultValues.exp.android.config;\n      }\n      configWithDefaultValues.exp.currentFullName = (0, _getFullName().getFullName)(configWithDefaultValues.exp);\n      configWithDefaultValues.exp.originalFullName = (0, _getFullName().getFullName)(configWithDefaultValues.exp);\n      (_configWithDefaultVal3 = configWithDefaultValues.exp.updates) === null || _configWithDefaultVal3 === void 0 ? true : delete _configWithDefaultVal3.codeSigningCertificate;\n      (_configWithDefaultVal4 = configWithDefaultValues.exp.updates) === null || _configWithDefaultVal4 === void 0 ? true : delete _configWithDefaultVal4.codeSigningMetadata;\n    }\n    return configWithDefaultValues;\n  }\n  function getContextConfig(config) {\n    return ensureConfigHasDefaultValues({\n      projectRoot: projectRoot,\n      exp: config.expo,\n      pkg: packageJson,\n      skipSDKVersionRequirement: true,\n      paths: paths,\n      packageJsonPath: packageJsonPath\n    }).exp;\n  }\n  if (paths.dynamicConfigPath) {\n    var _ref2 = (0, _getConfig().getDynamicConfig)(paths.dynamicConfigPath, {\n        projectRoot: projectRoot,\n        staticConfigPath: paths.staticConfigPath,\n        packageJsonPath: packageJsonPath,\n        config: getContextConfig(staticConfig)\n      }),\n      exportedObjectType = _ref2.exportedObjectType,\n      rawDynamicConfig = _ref2.config;\n    var dynamicConfig = reduceExpoObject(rawDynamicConfig) || {};\n    return fillAndReturnConfig(dynamicConfig, exportedObjectType);\n  }\n  return fillAndReturnConfig(staticConfig || {}, null);\n}\nfunction getPackageJson(projectRoot) {\n  var _getPackageJsonAndPat3 = getPackageJsonAndPath(projectRoot),\n    _getPackageJsonAndPat4 = _slicedToArray(_getPackageJsonAndPat3, 1),\n    pkg = _getPackageJsonAndPat4[0];\n  return pkg;\n}\nfunction getPackageJsonAndPath(projectRoot) {\n  var packageJsonPath = (0, _resolvePackageJson().getRootPackageJsonPath)(projectRoot);\n  return [_jsonFile().default.read(packageJsonPath), packageJsonPath];\n}\nfunction readConfigJson(projectRoot) {\n  var skipValidation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var skipSDKVersionRequirement = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var paths = getConfigFilePaths(projectRoot);\n  var rawStaticConfig = paths.staticConfigPath ? (0, _getConfig().getStaticConfig)(paths.staticConfigPath) : null;\n  var getConfigName = function getConfigName() {\n    if (paths.staticConfigPath) return \" `\" + _path().default.basename(paths.staticConfigPath) + \"`\";\n    return '';\n  };\n  var outputRootConfig = rawStaticConfig;\n  if (outputRootConfig === null || typeof outputRootConfig !== 'object') {\n    if (skipValidation) {\n      outputRootConfig = {\n        expo: {}\n      };\n    } else {\n      throw new (_Errors().ConfigError)(\"Project at path \" + _path().default.resolve(projectRoot) + \" does not contain a valid Expo config\" + getConfigName(), 'NOT_OBJECT');\n    }\n  }\n  var exp = outputRootConfig.expo;\n  if (exp === null || typeof exp !== 'object') {\n    throw new (_Errors().ConfigError)(\"Property 'expo' in\" + getConfigName() + \" for project at path \" + _path().default.resolve(projectRoot) + \" is not an object. Please make sure\" + getConfigName() + \" includes a managed Expo app config like this: \" + APP_JSON_EXAMPLE, 'NO_EXPO');\n  }\n  exp = _objectSpread({}, exp);\n  var _getPackageJsonAndPat5 = getPackageJsonAndPath(projectRoot),\n    _getPackageJsonAndPat6 = _slicedToArray(_getPackageJsonAndPat5, 2),\n    pkg = _getPackageJsonAndPat6[0],\n    packageJsonPath = _getPackageJsonAndPat6[1];\n  return _objectSpread(_objectSpread({}, ensureConfigHasDefaultValues({\n    projectRoot: projectRoot,\n    exp: exp,\n    pkg: pkg,\n    skipSDKVersionRequirement: skipSDKVersionRequirement,\n    paths: paths,\n    packageJsonPath: packageJsonPath\n  })), {}, {\n    mods: null,\n    dynamicConfigPath: null,\n    dynamicConfigObjectType: null,\n    rootConfig: _objectSpread({}, outputRootConfig)\n  }, paths);\n}\nfunction getConfigFilePaths(projectRoot) {\n  var customPaths = getCustomConfigFilePaths(projectRoot);\n  if (customPaths) {\n    return customPaths;\n  }\n  return {\n    dynamicConfigPath: getDynamicConfigFilePath(projectRoot),\n    staticConfigPath: getStaticConfigFilePath(projectRoot)\n  };\n}\nfunction getCustomConfigFilePaths(projectRoot) {\n  if (!customConfigPaths[projectRoot]) {\n    return null;\n  }\n  if (isDynamicFilePath(customConfigPaths[projectRoot])) {\n    return {\n      dynamicConfigPath: customConfigPaths[projectRoot],\n      staticConfigPath: null\n    };\n  }\n  return {\n    staticConfigPath: customConfigPaths[projectRoot],\n    dynamicConfigPath: null\n  };\n}\nfunction getDynamicConfigFilePath(projectRoot) {\n  for (var fileName of ['app.config.ts', 'app.config.js']) {\n    var configPath = _path().default.join(projectRoot, fileName);\n    if (_fs().default.existsSync(configPath)) {\n      return configPath;\n    }\n  }\n  return null;\n}\nfunction getStaticConfigFilePath(projectRoot) {\n  for (var fileName of ['app.config.json', 'app.json']) {\n    var configPath = _path().default.join(projectRoot, fileName);\n    if (_fs().default.existsSync(configPath)) {\n      return configPath;\n    }\n  }\n  return null;\n}\nfunction findConfigFile(projectRoot) {\n  var configPath;\n  if (customConfigPaths[projectRoot]) {\n    configPath = customConfigPaths[projectRoot];\n    return {\n      configPath: configPath,\n      configName: _path().default.basename(configPath),\n      configNamespace: 'expo'\n    };\n  } else {\n    configPath = _path().default.join(projectRoot, 'app.config.json');\n    if (!_fs().default.existsSync(configPath)) {\n      configPath = _path().default.join(projectRoot, 'app.json');\n    }\n  }\n  return {\n    configPath: configPath,\n    configName: _path().default.basename(configPath),\n    configNamespace: 'expo'\n  };\n}\nfunction configFilename(projectRoot) {\n  return findConfigFile(projectRoot).configName;\n}\nfunction readExpRcAsync(_x) {\n  return _readExpRcAsync.apply(this, arguments);\n}\nfunction _readExpRcAsync() {\n  _readExpRcAsync = _asyncToGenerator(function* (projectRoot) {\n    var expRcPath = _path().default.join(projectRoot, '.exprc');\n    return yield _jsonFile().default.readAsync(expRcPath, {\n      json5: true,\n      cantReadFileDefault: {}\n    });\n  });\n  return _readExpRcAsync.apply(this, arguments);\n}\nvar customConfigPaths = {};\nfunction resetCustomConfigPaths() {\n  for (var key of Object.keys(customConfigPaths)) {\n    delete customConfigPaths[key];\n  }\n}\nfunction setCustomConfigPath(projectRoot, configPath) {\n  customConfigPaths[projectRoot] = configPath;\n}\nfunction modifyConfigAsync(_x2, _x3) {\n  return _modifyConfigAsync.apply(this, arguments);\n}\nfunction _modifyConfigAsync() {\n  _modifyConfigAsync = _asyncToGenerator(function* (projectRoot, modifications) {\n    var readOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var writeOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    var config = getConfig(projectRoot, readOptions);\n    if (config.dynamicConfigPath) {\n      return {\n        type: 'warn',\n        message: \"Cannot automatically write to dynamic config at: \" + _path().default.relative(projectRoot, config.dynamicConfigPath),\n        config: null\n      };\n    } else if (config.staticConfigPath) {\n      var outputConfig;\n      if (config.rootConfig.expo) {\n        outputConfig = _objectSpread(_objectSpread({}, config.rootConfig), {}, {\n          expo: _objectSpread(_objectSpread({}, config.rootConfig.expo), modifications)\n        });\n      } else {\n        outputConfig = _objectSpread(_objectSpread({}, config.rootConfig), modifications);\n      }\n      if (!writeOptions.dryRun) {\n        yield _jsonFile().default.writeAsync(config.staticConfigPath, outputConfig, {\n          json5: false\n        });\n      }\n      return {\n        type: 'success',\n        config: outputConfig\n      };\n    }\n    return {\n      type: 'fail',\n      message: 'No config exists',\n      config: null\n    };\n  });\n  return _modifyConfigAsync.apply(this, arguments);\n}\nvar APP_JSON_EXAMPLE = JSON.stringify({\n  expo: {\n    name: 'My app',\n    slug: 'my-app',\n    sdkVersion: '...'\n  }\n});\nfunction ensureConfigHasDefaultValues(_ref3) {\n  var projectRoot = _ref3.projectRoot,\n    exp = _ref3.exp,\n    pkg = _ref3.pkg,\n    paths = _ref3.paths,\n    packageJsonPath = _ref3.packageJsonPath,\n    _ref3$skipSDKVersionR = _ref3.skipSDKVersionRequirement,\n    skipSDKVersionRequirement = _ref3$skipSDKVersionR === void 0 ? false : _ref3$skipSDKVersionR;\n  var _exp$name, _exp$slug, _exp$version;\n  if (!exp) {\n    exp = {};\n  }\n  exp = (0, _withInternal().withInternal)(exp, _objectSpread(_objectSpread({\n    projectRoot: projectRoot\n  }, paths !== null && paths !== void 0 ? paths : {}), {}, {\n    packageJsonPath: packageJsonPath\n  }));\n  var pkgName = typeof pkg.name === 'string' ? pkg.name : _path().default.basename(projectRoot);\n  var pkgVersion = typeof pkg.version === 'string' ? pkg.version : '1.0.0';\n  var pkgWithDefaults = _objectSpread(_objectSpread({}, pkg), {}, {\n    name: pkgName,\n    version: pkgVersion\n  });\n  var name = (_exp$name = exp.name) !== null && _exp$name !== void 0 ? _exp$name : pkgName;\n  var slug = (_exp$slug = exp.slug) !== null && _exp$slug !== void 0 ? _exp$slug : (0, _slugify().default)(name.toLowerCase());\n  var version = (_exp$version = exp.version) !== null && _exp$version !== void 0 ? _exp$version : pkgVersion;\n  var description = exp.description;\n  if (!description && typeof pkg.description === 'string') {\n    description = pkg.description;\n  }\n  var expWithDefaults = _objectSpread(_objectSpread({}, exp), {}, {\n    name: name,\n    slug: slug,\n    version: version,\n    description: description\n  });\n  var sdkVersion;\n  try {\n    sdkVersion = (0, _Project().getExpoSDKVersion)(projectRoot, expWithDefaults);\n  } catch (error) {\n    if (!skipSDKVersionRequirement) throw error;\n  }\n  var platforms = exp.platforms;\n  if (!platforms) {\n    platforms = getSupportedPlatforms(projectRoot);\n  }\n  return {\n    exp: _objectSpread(_objectSpread({}, expWithDefaults), {}, {\n      sdkVersion: sdkVersion,\n      platforms: platforms\n    }),\n    pkg: pkgWithDefaults\n  };\n}\nfunction writeConfigJsonAsync(_x4, _x5) {\n  return _writeConfigJsonAsync.apply(this, arguments);\n}\nfunction _writeConfigJsonAsync() {\n  _writeConfigJsonAsync = _asyncToGenerator(function* (projectRoot, options) {\n    var paths = getConfigFilePaths(projectRoot);\n    var _readConfigJson = readConfigJson(projectRoot),\n      exp = _readConfigJson.exp,\n      pkg = _readConfigJson.pkg,\n      rootConfig = _readConfigJson.rootConfig,\n      dynamicConfigObjectType = _readConfigJson.dynamicConfigObjectType,\n      staticConfigPath = _readConfigJson.staticConfigPath;\n    exp = _objectSpread(_objectSpread({}, rootConfig.expo), options);\n    rootConfig = _objectSpread(_objectSpread({}, rootConfig), {}, {\n      expo: exp\n    });\n    if (paths.staticConfigPath) {\n      yield _jsonFile().default.writeAsync(paths.staticConfigPath, rootConfig, {\n        json5: false\n      });\n    } else {\n      console.log('Failed to write to config: ', options);\n    }\n    return _objectSpread({\n      exp: exp,\n      pkg: pkg,\n      rootConfig: rootConfig,\n      staticConfigPath: staticConfigPath,\n      dynamicConfigObjectType: dynamicConfigObjectType\n    }, paths);\n  });\n  return _writeConfigJsonAsync.apply(this, arguments);\n}\nvar DEFAULT_BUILD_PATH = \"web-build\";\nfunction getWebOutputPath() {\n  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var _expo$web, _expo$web$build;\n  if (process.env.WEBPACK_BUILD_OUTPUT_PATH) {\n    return process.env.WEBPACK_BUILD_OUTPUT_PATH;\n  }\n  var expo = config.expo || config || {};\n  return (expo === null || expo === void 0 ? void 0 : (_expo$web = expo.web) === null || _expo$web === void 0 ? void 0 : (_expo$web$build = _expo$web.build) === null || _expo$web$build === void 0 ? void 0 : _expo$web$build.output) || DEFAULT_BUILD_PATH;\n}\nfunction getNameFromConfig() {\n  var exp = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var appManifest = exp.expo || exp;\n  var _appManifest$web = appManifest.web,\n    web = _appManifest$web === void 0 ? {} : _appManifest$web;\n  var appName = exp.displayName || appManifest.displayName || appManifest.name;\n  var webName = web.name || appName;\n  return {\n    appName: appName,\n    webName: webName\n  };\n}\nfunction getDefaultTarget(projectRoot, exp) {\n  var _exp;\n  (_exp = exp) !== null && _exp !== void 0 ? _exp : exp = getConfig(projectRoot, {\n    skipSDKVersionRequirement: true\n  }).exp;\n  if (exp.sdkVersion && exp.sdkVersion !== 'UNVERSIONED' && _semver().default.lt(exp.sdkVersion, '37.0.0')) {\n    return 'managed';\n  }\n  return isBareWorkflowProject(projectRoot) ? 'bare' : 'managed';\n}\nfunction isBareWorkflowProject(projectRoot) {\n  var _getPackageJsonAndPat7 = getPackageJsonAndPath(projectRoot),\n    _getPackageJsonAndPat8 = _slicedToArray(_getPackageJsonAndPat7, 1),\n    pkg = _getPackageJsonAndPat8[0];\n  if (pkg.dependencies && pkg.dependencies.expokit) {\n    return false;\n  }\n  var xcodeprojFiles = (0, _glob().sync)('ios/**/*.xcodeproj', {\n    absolute: true,\n    cwd: projectRoot\n  });\n  if (xcodeprojFiles.length) {\n    return true;\n  }\n  var gradleFiles = (0, _glob().sync)('android/**/*.gradle', {\n    absolute: true,\n    cwd: projectRoot\n  });\n  if (gradleFiles.length) {\n    return true;\n  }\n  return false;\n}\nfunction isDynamicFilePath(filePath) {\n  return !!filePath.match(/\\.[j|t]s$/);\n}\nfunction getProjectConfigDescription(projectRoot) {\n  var paths = getConfigFilePaths(projectRoot);\n  return getProjectConfigDescriptionWithPaths(projectRoot, paths);\n}\nfunction getProjectConfigDescriptionWithPaths(projectRoot, projectConfig) {\n  if (projectConfig.dynamicConfigPath) {\n    var relativeDynamicConfigPath = _path().default.relative(projectRoot, projectConfig.dynamicConfigPath);\n    if (projectConfig.staticConfigPath) {\n      return relativeDynamicConfigPath + \" or \" + _path().default.relative(projectRoot, projectConfig.staticConfigPath);\n    }\n    return relativeDynamicConfigPath;\n  } else if (projectConfig.staticConfigPath) {\n    return _path().default.relative(projectRoot, projectConfig.staticConfigPath);\n  }\n  return 'app.json';\n}","map":{"version":3,"names":["_jsonFile","data","_interopRequireDefault","require","_fs","_glob","_path","_resolveFrom","_semver","_slugify","_Errors","_Project","_getConfig","_getFullName","_withConfigPlugins","_withInternal","_resolvePackageJson","_Config","Object","keys","forEach","key","prototype","hasOwnProperty","call","_exportNames","exports","defineProperty","enumerable","get","_isLegacyImportsEnabled","reduceExpoObject","config","_config$expo","undefined","_ref","expo","mods","_objectWithoutProperties","_excluded","getSupportedPlatforms","projectRoot","platforms","default","silent","push","getConfig","options","arguments","length","paths","getConfigFilePaths","rawStaticConfig","staticConfigPath","getStaticConfig","rootConfig","staticConfig","_getPackageJsonAndPat","getPackageJsonAndPath","_getPackageJsonAndPat2","_slicedToArray","packageJson","packageJsonPath","fillAndReturnConfig","dynamicConfigObjectType","configWithDefaultValues","_objectSpread","ensureConfigHasDefaultValues","exp","pkg","skipSDKVersionRequirement","dynamicConfigPath","isModdedConfig","_config$mods","withConfigPlugins","skipPlugins","isPublicConfig","_configWithDefaultVal","_configWithDefaultVal2","_configWithDefaultVal3","_configWithDefaultVal4","_internal","hooks","ios","android","currentFullName","getFullName","originalFullName","updates","codeSigningCertificate","codeSigningMetadata","getContextConfig","_ref2","getDynamicConfig","exportedObjectType","rawDynamicConfig","dynamicConfig","getPackageJson","_getPackageJsonAndPat3","_getPackageJsonAndPat4","getRootPackageJsonPath","read","readConfigJson","skipValidation","getConfigName","basename","outputRootConfig","ConfigError","resolve","APP_JSON_EXAMPLE","_getPackageJsonAndPat5","_getPackageJsonAndPat6","customPaths","getCustomConfigFilePaths","getDynamicConfigFilePath","getStaticConfigFilePath","customConfigPaths","isDynamicFilePath","fileName","configPath","join","existsSync","findConfigFile","configName","configNamespace","configFilename","readExpRcAsync","_x","_readExpRcAsync","apply","_asyncToGenerator","expRcPath","readAsync","json5","cantReadFileDefault","resetCustomConfigPaths","setCustomConfigPath","modifyConfigAsync","_x2","_x3","_modifyConfigAsync","modifications","readOptions","writeOptions","type","message","relative","outputConfig","dryRun","writeAsync","JSON","stringify","name","slug","sdkVersion","_ref3","_ref3$skipSDKVersionR","_exp$name","_exp$slug","_exp$version","withInternal","pkgName","pkgVersion","version","pkgWithDefaults","toLowerCase","description","expWithDefaults","getExpoSDKVersion","error","writeConfigJsonAsync","_x4","_x5","_writeConfigJsonAsync","_readConfigJson","console","log","DEFAULT_BUILD_PATH","getWebOutputPath","_expo$web","_expo$web$build","process","env","WEBPACK_BUILD_OUTPUT_PATH","web","build","output","getNameFromConfig","appManifest","_appManifest$web","appName","displayName","webName","getDefaultTarget","_exp","lt","isBareWorkflowProject","_getPackageJsonAndPat7","_getPackageJsonAndPat8","dependencies","expokit","xcodeprojFiles","sync","absolute","cwd","gradleFiles","filePath","match","getProjectConfigDescription","getProjectConfigDescriptionWithPaths","projectConfig","relativeDynamicConfigPath"],"sources":["/Users/henriqueeidt/Documents/Projects/poc-web-mobile-components/component-library/node_modules/@expo/config/src/Config.ts"],"sourcesContent":["import { ModConfig } from '@expo/config-plugins';\nimport JsonFile, { JSONObject } from '@expo/json-file';\nimport fs from 'fs';\nimport { sync as globSync } from 'glob';\nimport path from 'path';\nimport resolveFrom from 'resolve-from';\nimport semver from 'semver';\nimport slugify from 'slugify';\n\nimport {\n  AppJSONConfig,\n  ConfigFilePaths,\n  ExpoConfig,\n  ExpRc,\n  GetConfigOptions,\n  PackageJSONConfig,\n  Platform,\n  ProjectConfig,\n  ProjectTarget,\n  WriteConfigOptions,\n} from './Config.types';\nimport { ConfigError } from './Errors';\nimport { getExpoSDKVersion } from './Project';\nimport { getDynamicConfig, getStaticConfig } from './getConfig';\nimport { getFullName } from './getFullName';\nimport { withConfigPlugins } from './plugins/withConfigPlugins';\nimport { withInternal } from './plugins/withInternal';\nimport { getRootPackageJsonPath } from './resolvePackageJson';\n\ntype SplitConfigs = { expo: ExpoConfig; mods: ModConfig };\n\n/**\n * If a config has an `expo` object then that will be used as the config.\n * This method reduces out other top level values if an `expo` object exists.\n *\n * @param config Input config object to reduce\n */\nfunction reduceExpoObject(config?: any): SplitConfigs {\n  if (!config) return config === undefined ? null : config;\n\n  const { mods, ...expo } = config.expo ?? config;\n\n  return {\n    expo,\n    mods,\n  };\n}\n\n/**\n * Get all platforms that a project is currently capable of running.\n *\n * @param projectRoot\n * @param exp\n */\nfunction getSupportedPlatforms(projectRoot: string): Platform[] {\n  const platforms: Platform[] = [];\n  if (resolveFrom.silent(projectRoot, 'react-native')) {\n    platforms.push('ios', 'android');\n  }\n  if (resolveFrom.silent(projectRoot, 'react-native-web')) {\n    platforms.push('web');\n  }\n  return platforms;\n}\n\n/**\n * Evaluate the config for an Expo project.\n * If a function is exported from the `app.config.js` then a partial config will be passed as an argument.\n * The partial config is composed from any existing app.json, and certain fields from the `package.json` like name and description.\n *\n * If options.isPublicConfig is true, the Expo config will include only public-facing options (omitting private keys).\n * The resulting config should be suitable for hosting or embedding in a publicly readable location.\n *\n * **Example**\n * ```js\n * module.exports = function({ config }) {\n *   // mutate the config before returning it.\n *   config.slug = 'new slug'\n *   return { expo: config };\n * }\n * ```\n *\n * **Supports**\n * - `app.config.ts`\n * - `app.config.js`\n * - `app.config.json`\n * - `app.json`\n *\n * @param projectRoot the root folder containing all of your application code\n * @param options enforce criteria for a project config\n */\nexport function getConfig(projectRoot: string, options: GetConfigOptions = {}): ProjectConfig {\n  const paths = getConfigFilePaths(projectRoot);\n\n  const rawStaticConfig = paths.staticConfigPath ? getStaticConfig(paths.staticConfigPath) : null;\n  // For legacy reasons, always return an object.\n  const rootConfig = (rawStaticConfig || {}) as AppJSONConfig;\n  const staticConfig = reduceExpoObject(rawStaticConfig) || {};\n\n  // Can only change the package.json location if an app.json or app.config.json exists\n  const [packageJson, packageJsonPath] = getPackageJsonAndPath(projectRoot);\n\n  function fillAndReturnConfig(config: SplitConfigs, dynamicConfigObjectType: string | null) {\n    const configWithDefaultValues = {\n      ...ensureConfigHasDefaultValues({\n        projectRoot,\n        exp: config.expo,\n        pkg: packageJson,\n        skipSDKVersionRequirement: options.skipSDKVersionRequirement,\n        paths,\n        packageJsonPath,\n      }),\n      mods: config.mods,\n      dynamicConfigObjectType,\n      rootConfig,\n      dynamicConfigPath: paths.dynamicConfigPath,\n      staticConfigPath: paths.staticConfigPath,\n    };\n\n    if (options.isModdedConfig) {\n      // @ts-ignore: Add the mods back to the object.\n      configWithDefaultValues.exp.mods = config.mods ?? null;\n    }\n\n    // Apply static json plugins, should be done after _internal\n    configWithDefaultValues.exp = withConfigPlugins(\n      configWithDefaultValues.exp,\n      !!options.skipPlugins\n    );\n\n    if (!options.isModdedConfig) {\n      // @ts-ignore: Delete mods added by static plugins when they won't have a chance to be evaluated\n      delete configWithDefaultValues.exp.mods;\n    }\n\n    if (options.isPublicConfig) {\n      // Remove internal values with references to user's file paths from the public config.\n      delete configWithDefaultValues.exp._internal;\n\n      if (configWithDefaultValues.exp.hooks) {\n        delete configWithDefaultValues.exp.hooks;\n      }\n      if (configWithDefaultValues.exp.ios?.config) {\n        delete configWithDefaultValues.exp.ios.config;\n      }\n      if (configWithDefaultValues.exp.android?.config) {\n        delete configWithDefaultValues.exp.android.config;\n      }\n\n      // These value will be overwritten when the manifest is being served from the host (i.e. not completely accurate).\n      // @ts-ignore: currentFullName not on type yet.\n      configWithDefaultValues.exp.currentFullName = getFullName(configWithDefaultValues.exp);\n      // @ts-ignore: originalFullName not on type yet.\n      configWithDefaultValues.exp.originalFullName = getFullName(configWithDefaultValues.exp);\n\n      delete configWithDefaultValues.exp.updates?.codeSigningCertificate;\n      delete configWithDefaultValues.exp.updates?.codeSigningMetadata;\n    }\n\n    return configWithDefaultValues;\n  }\n\n  // Fill in the static config\n  function getContextConfig(config: SplitConfigs) {\n    return ensureConfigHasDefaultValues({\n      projectRoot,\n      exp: config.expo,\n      pkg: packageJson,\n      skipSDKVersionRequirement: true,\n      paths,\n      packageJsonPath,\n    }).exp;\n  }\n\n  if (paths.dynamicConfigPath) {\n    // No app.config.json or app.json but app.config.js\n    const { exportedObjectType, config: rawDynamicConfig } = getDynamicConfig(\n      paths.dynamicConfigPath,\n      {\n        projectRoot,\n        staticConfigPath: paths.staticConfigPath,\n        packageJsonPath,\n        config: getContextConfig(staticConfig),\n      }\n    );\n    // Allow for the app.config.js to `export default null;`\n    // Use `dynamicConfigPath` to detect if a dynamic config exists.\n    const dynamicConfig = reduceExpoObject(rawDynamicConfig) || {};\n    return fillAndReturnConfig(dynamicConfig, exportedObjectType);\n  }\n\n  // No app.config.js but json or no config\n  return fillAndReturnConfig(staticConfig || {}, null);\n}\n\nexport function getPackageJson(projectRoot: string): PackageJSONConfig {\n  const [pkg] = getPackageJsonAndPath(projectRoot);\n  return pkg;\n}\n\nfunction getPackageJsonAndPath(projectRoot: string): [PackageJSONConfig, string] {\n  const packageJsonPath = getRootPackageJsonPath(projectRoot);\n  return [JsonFile.read(packageJsonPath), packageJsonPath];\n}\n\nexport function readConfigJson(\n  projectRoot: string,\n  skipValidation: boolean = false,\n  skipSDKVersionRequirement: boolean = false\n): ProjectConfig {\n  const paths = getConfigFilePaths(projectRoot);\n\n  const rawStaticConfig = paths.staticConfigPath ? getStaticConfig(paths.staticConfigPath) : null;\n\n  const getConfigName = (): string => {\n    if (paths.staticConfigPath) return ` \\`${path.basename(paths.staticConfigPath)}\\``;\n    return '';\n  };\n\n  let outputRootConfig = rawStaticConfig as JSONObject | null;\n  if (outputRootConfig === null || typeof outputRootConfig !== 'object') {\n    if (skipValidation) {\n      outputRootConfig = { expo: {} };\n    } else {\n      throw new ConfigError(\n        `Project at path ${path.resolve(\n          projectRoot\n        )} does not contain a valid Expo config${getConfigName()}`,\n        'NOT_OBJECT'\n      );\n    }\n  }\n  let exp = outputRootConfig.expo as Partial<ExpoConfig>;\n  if (exp === null || typeof exp !== 'object') {\n    throw new ConfigError(\n      `Property 'expo' in${getConfigName()} for project at path ${path.resolve(\n        projectRoot\n      )} is not an object. Please make sure${getConfigName()} includes a managed Expo app config like this: ${APP_JSON_EXAMPLE}`,\n      'NO_EXPO'\n    );\n  }\n\n  exp = { ...exp };\n\n  const [pkg, packageJsonPath] = getPackageJsonAndPath(projectRoot);\n\n  return {\n    ...ensureConfigHasDefaultValues({\n      projectRoot,\n      exp,\n      pkg,\n      skipSDKVersionRequirement,\n      paths,\n      packageJsonPath,\n    }),\n    mods: null,\n    dynamicConfigPath: null,\n    dynamicConfigObjectType: null,\n    rootConfig: { ...outputRootConfig } as AppJSONConfig,\n    ...paths,\n  };\n}\n\n/**\n * Get the static and dynamic config paths for a project. Also accounts for custom paths.\n *\n * @param projectRoot\n */\nexport function getConfigFilePaths(projectRoot: string): ConfigFilePaths {\n  const customPaths = getCustomConfigFilePaths(projectRoot);\n  if (customPaths) {\n    return customPaths;\n  }\n\n  return {\n    dynamicConfigPath: getDynamicConfigFilePath(projectRoot),\n    staticConfigPath: getStaticConfigFilePath(projectRoot),\n  };\n}\n\nfunction getCustomConfigFilePaths(projectRoot: string): ConfigFilePaths | null {\n  if (!customConfigPaths[projectRoot]) {\n    return null;\n  }\n  // If the user picks a custom config path, we will only use that and skip searching for a secondary config.\n  if (isDynamicFilePath(customConfigPaths[projectRoot])) {\n    return {\n      dynamicConfigPath: customConfigPaths[projectRoot],\n      staticConfigPath: null,\n    };\n  }\n  // Anything that's not js or ts will be treated as json.\n  return { staticConfigPath: customConfigPaths[projectRoot], dynamicConfigPath: null };\n}\n\nfunction getDynamicConfigFilePath(projectRoot: string): string | null {\n  for (const fileName of ['app.config.ts', 'app.config.js']) {\n    const configPath = path.join(projectRoot, fileName);\n    if (fs.existsSync(configPath)) {\n      return configPath;\n    }\n  }\n  return null;\n}\n\nfunction getStaticConfigFilePath(projectRoot: string): string | null {\n  for (const fileName of ['app.config.json', 'app.json']) {\n    const configPath = path.join(projectRoot, fileName);\n    if (fs.existsSync(configPath)) {\n      return configPath;\n    }\n  }\n  return null;\n}\n\n// TODO: This should account for dynamic configs\nexport function findConfigFile(\n  projectRoot: string\n): { configPath: string; configName: string; configNamespace: 'expo' } {\n  let configPath: string;\n  // Check for a custom config path first.\n  if (customConfigPaths[projectRoot]) {\n    configPath = customConfigPaths[projectRoot];\n    // We shouldn't verify if the file exists because\n    // the user manually specified that this path should be used.\n    return {\n      configPath,\n      configName: path.basename(configPath),\n      configNamespace: 'expo',\n    };\n  } else {\n    // app.config.json takes higher priority over app.json\n    configPath = path.join(projectRoot, 'app.config.json');\n    if (!fs.existsSync(configPath)) {\n      configPath = path.join(projectRoot, 'app.json');\n    }\n  }\n\n  return {\n    configPath,\n    configName: path.basename(configPath),\n    configNamespace: 'expo',\n  };\n}\n\n// TODO: deprecate\nexport function configFilename(projectRoot: string): string {\n  return findConfigFile(projectRoot).configName;\n}\n\nexport async function readExpRcAsync(projectRoot: string): Promise<ExpRc> {\n  const expRcPath = path.join(projectRoot, '.exprc');\n  return await JsonFile.readAsync(expRcPath, { json5: true, cantReadFileDefault: {} });\n}\n\nconst customConfigPaths: { [projectRoot: string]: string } = {};\n\nexport function resetCustomConfigPaths(): void {\n  for (const key of Object.keys(customConfigPaths)) {\n    delete customConfigPaths[key];\n  }\n}\n\nexport function setCustomConfigPath(projectRoot: string, configPath: string): void {\n  customConfigPaths[projectRoot] = configPath;\n}\n\n/**\n * Attempt to modify an Expo project config.\n * This will only fully work if the project is using static configs only.\n * Otherwise 'warn' | 'fail' will return with a message about why the config couldn't be updated.\n * The potentially modified config object will be returned for testing purposes.\n *\n * @param projectRoot\n * @param modifications modifications to make to an existing config\n * @param readOptions options for reading the current config file\n * @param writeOptions If true, the static config file will not be rewritten\n */\nexport async function modifyConfigAsync(\n  projectRoot: string,\n  modifications: Partial<ExpoConfig>,\n  readOptions: GetConfigOptions = {},\n  writeOptions: WriteConfigOptions = {}\n): Promise<{\n  type: 'success' | 'warn' | 'fail';\n  message?: string;\n  config: AppJSONConfig | null;\n}> {\n  const config = getConfig(projectRoot, readOptions);\n  if (config.dynamicConfigPath) {\n    // We cannot automatically write to a dynamic config.\n    /* Currently we should just use the safest approach possible, informing the user that they'll need to manually modify their dynamic config.\n\n    if (config.staticConfigPath) {\n      // Both a dynamic and a static config exist.\n      if (config.dynamicConfigObjectType === 'function') {\n        // The dynamic config exports a function, this means it possibly extends the static config.\n      } else {\n        // Dynamic config ignores the static config, there isn't a reason to automatically write to it.\n        // Instead we should warn the user to add values to their dynamic config.\n      }\n    }\n    */\n    return {\n      type: 'warn',\n      message: `Cannot automatically write to dynamic config at: ${path.relative(\n        projectRoot,\n        config.dynamicConfigPath\n      )}`,\n      config: null,\n    };\n  } else if (config.staticConfigPath) {\n    // Static with no dynamic config, this means we can append to the config automatically.\n    let outputConfig: AppJSONConfig;\n    // If the config has an expo object (app.json) then append the options to that object.\n    if (config.rootConfig.expo) {\n      outputConfig = {\n        ...config.rootConfig,\n        expo: { ...config.rootConfig.expo, ...modifications },\n      };\n    } else {\n      // Otherwise (app.config.json) just add the config modification to the top most level.\n      outputConfig = { ...config.rootConfig, ...modifications };\n    }\n    if (!writeOptions.dryRun) {\n      await JsonFile.writeAsync(config.staticConfigPath, outputConfig, { json5: false });\n    }\n    return { type: 'success', config: outputConfig };\n  }\n\n  return { type: 'fail', message: 'No config exists', config: null };\n}\n\nconst APP_JSON_EXAMPLE = JSON.stringify({\n  expo: {\n    name: 'My app',\n    slug: 'my-app',\n    sdkVersion: '...',\n  },\n});\n\nfunction ensureConfigHasDefaultValues({\n  projectRoot,\n  exp,\n  pkg,\n  paths,\n  packageJsonPath,\n  skipSDKVersionRequirement = false,\n}: {\n  projectRoot: string;\n  exp: Partial<ExpoConfig> | null;\n  pkg: JSONObject;\n  skipSDKVersionRequirement?: boolean;\n  paths?: ConfigFilePaths;\n  packageJsonPath?: string;\n}): { exp: ExpoConfig; pkg: PackageJSONConfig } {\n  if (!exp) {\n    exp = {};\n  }\n  exp = withInternal(exp as any, {\n    projectRoot,\n    ...(paths ?? {}),\n    packageJsonPath,\n  });\n  // Defaults for package.json fields\n  const pkgName = typeof pkg.name === 'string' ? pkg.name : path.basename(projectRoot);\n  const pkgVersion = typeof pkg.version === 'string' ? pkg.version : '1.0.0';\n\n  const pkgWithDefaults = { ...pkg, name: pkgName, version: pkgVersion };\n\n  // Defaults for app.json/app.config.js fields\n  const name = exp.name ?? pkgName;\n  const slug = exp.slug ?? slugify(name.toLowerCase());\n  const version = exp.version ?? pkgVersion;\n  let description = exp.description;\n  if (!description && typeof pkg.description === 'string') {\n    description = pkg.description;\n  }\n\n  const expWithDefaults = { ...exp, name, slug, version, description };\n\n  let sdkVersion;\n  try {\n    sdkVersion = getExpoSDKVersion(projectRoot, expWithDefaults);\n  } catch (error) {\n    if (!skipSDKVersionRequirement) throw error;\n  }\n\n  let platforms = exp.platforms;\n  if (!platforms) {\n    platforms = getSupportedPlatforms(projectRoot);\n  }\n\n  return {\n    exp: { ...expWithDefaults, sdkVersion, platforms },\n    pkg: pkgWithDefaults,\n  };\n}\n\nexport async function writeConfigJsonAsync(\n  projectRoot: string,\n  options: object\n): Promise<ProjectConfig> {\n  const paths = getConfigFilePaths(projectRoot);\n  let { exp, pkg, rootConfig, dynamicConfigObjectType, staticConfigPath } = readConfigJson(\n    projectRoot\n  );\n  exp = { ...rootConfig.expo, ...options };\n  rootConfig = { ...rootConfig, expo: exp };\n\n  if (paths.staticConfigPath) {\n    await JsonFile.writeAsync(paths.staticConfigPath, rootConfig, { json5: false });\n  } else {\n    console.log('Failed to write to config: ', options);\n  }\n\n  return {\n    exp,\n    pkg,\n    rootConfig,\n    staticConfigPath,\n    dynamicConfigObjectType,\n    ...paths,\n  };\n}\nconst DEFAULT_BUILD_PATH = `web-build`;\n\nexport function getWebOutputPath(config: { [key: string]: any } = {}): string {\n  if (process.env.WEBPACK_BUILD_OUTPUT_PATH) {\n    return process.env.WEBPACK_BUILD_OUTPUT_PATH;\n  }\n  const expo = config.expo || config || {};\n  return expo?.web?.build?.output || DEFAULT_BUILD_PATH;\n}\n\nexport function getNameFromConfig(\n  exp: Record<string, any> = {}\n): { appName?: string; webName?: string } {\n  // For RN CLI support\n  const appManifest = exp.expo || exp;\n  const { web = {} } = appManifest;\n\n  // rn-cli apps use a displayName value as well.\n  const appName = exp.displayName || appManifest.displayName || appManifest.name;\n  const webName = web.name || appName;\n\n  return {\n    appName,\n    webName,\n  };\n}\n\nexport function getDefaultTarget(\n  projectRoot: string,\n  exp?: Pick<ExpoConfig, 'sdkVersion'>\n): ProjectTarget {\n  exp ??= getConfig(projectRoot, { skipSDKVersionRequirement: true }).exp;\n\n  // before SDK 37, always default to managed to preserve previous behavior\n  if (exp.sdkVersion && exp.sdkVersion !== 'UNVERSIONED' && semver.lt(exp.sdkVersion, '37.0.0')) {\n    return 'managed';\n  }\n  return isBareWorkflowProject(projectRoot) ? 'bare' : 'managed';\n}\n\nfunction isBareWorkflowProject(projectRoot: string): boolean {\n  const [pkg] = getPackageJsonAndPath(projectRoot);\n\n  if (pkg.dependencies && pkg.dependencies.expokit) {\n    return false;\n  }\n\n  const xcodeprojFiles = globSync('ios/**/*.xcodeproj', {\n    absolute: true,\n    cwd: projectRoot,\n  });\n  if (xcodeprojFiles.length) {\n    return true;\n  }\n  const gradleFiles = globSync('android/**/*.gradle', {\n    absolute: true,\n    cwd: projectRoot,\n  });\n  if (gradleFiles.length) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * true if the file is .js or .ts\n *\n * @param filePath\n */\nfunction isDynamicFilePath(filePath: string): boolean {\n  return !!filePath.match(/\\.[j|t]s$/);\n}\n\n/**\n * Return a useful name describing the project config.\n * - dynamic: app.config.js\n * - static: app.json\n * - custom path app config relative to root folder\n * - both: app.config.js or app.json\n */\nexport function getProjectConfigDescription(projectRoot: string): string {\n  const paths = getConfigFilePaths(projectRoot);\n  return getProjectConfigDescriptionWithPaths(projectRoot, paths);\n}\n\n/**\n * Returns a string describing the configurations used for the given project root.\n * Will return null if no config is found.\n *\n * @param projectRoot\n * @param projectConfig\n */\nexport function getProjectConfigDescriptionWithPaths(\n  projectRoot: string,\n  projectConfig: ConfigFilePaths\n): string {\n  if (projectConfig.dynamicConfigPath) {\n    const relativeDynamicConfigPath = path.relative(projectRoot, projectConfig.dynamicConfigPath);\n    if (projectConfig.staticConfigPath) {\n      return `${relativeDynamicConfigPath} or ${path.relative(\n        projectRoot,\n        projectConfig.staticConfigPath\n      )}`;\n    }\n    return relativeDynamicConfigPath;\n  } else if (projectConfig.staticConfigPath) {\n    return path.relative(projectRoot, projectConfig.staticConfigPath);\n  }\n  // If a config doesn't exist, our tooling will generate a static app.json\n  return 'app.json';\n}\n\nexport * from './Config.types';\n\nexport { isLegacyImportsEnabled } from './isLegacyImportsEnabled';\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}
"use strict";var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");exports.__esModule = true;exports.default = _default;var _compiler = require("@marko/compiler");
var _babelUtils = require("@marko/babel-utils");







var _util = require("./util");
var _withPreviousLocation = _interopRequireDefault(require("../util/with-previous-location"));

const EMPTY_OBJECT = {};
const parentIdentifierLookup = new WeakMap();

// TODO: optimize inline repeated @tags.

function _default(tag) {
  const { node } = tag;
  const namePath = tag.get("name");
  const tagName = namePath.node.value;
  const parentPath = (0, _babelUtils.findParentTag)(tag);

  (0, _babelUtils.assertNoArgs)(tag);

  if (!parentPath) {
    throw namePath.buildCodeFrameError(
    "@tags must be nested within another element.");

  }

  const parentAttributes = parentPath.get("attributes");
  const tagDef = (0, _babelUtils.getTagDef)(tag);
  const { isRepeated, targetProperty = tagName.slice(1) } =
  tagDef || EMPTY_OBJECT;
  const isDynamic = isRepeated || parentPath !== tag.parentPath.parentPath;
  parentPath.node.exampleAttributeTag = node;

  if (isDynamic) {
    if (!parentPath.node.hasDynamicAttrTags) {
      const body = parentPath.get("body").get("body");
      parentPath.node.hasDynamicAttrTags = true;

      for (let i = body.length; i--;) {
        const child = body[i];
        if (isAttributeTagChild(child)) {
          child.insertAfter(_compiler.types.stringLiteral("END_ATTRIBUTE_TAGS"));
          break;
        }
      }
    }
  } else {
    const previousAttr = parentAttributes.find(
    (attr) => attr.get("name").node === targetProperty);


    if (previousAttr) {
      const previousValue = previousAttr.get("value").node;
      if (_compiler.types.isObjectExpression(previousValue)) {
        previousAttr.set(
        "value",
        _compiler.types.arrayExpression([previousValue, getAttrTagObject(tag)]));

      } else if (_compiler.types.isArrayExpression(previousAttr)) {
        previousAttr.elements.push(getAttrTagObject(tag));
      } else {
        previousAttr.set(
        "value",
        _compiler.types.callExpression(
        (0, _babelUtils.importDefault)(
        tag.hub.file,
        "marko/src/runtime/helpers/repeatable.js",
        "marko_repeatable"),

        [previousValue, getAttrTagObject(tag)]));


      }
    } else {
      parentPath.pushContainer(
      "attributes",
      _compiler.types.markoAttribute(targetProperty, getAttrTagObject(tag)));

    }

    tag.remove();
    return;
  }

  let identifiers = parentIdentifierLookup.get(parentPath);

  if (!identifiers) {
    parentIdentifierLookup.set(parentPath, identifiers = {});
  }

  let identifier = identifiers[targetProperty];

  if (!identifier) {
    identifier = identifiers[targetProperty] =
    tag.scope.generateUidIdentifier(targetProperty);
    parentPath.
    get("body").
    unshiftContainer(
    "body",
    _compiler.types.variableDeclaration(isRepeated ? "const" : "let", [
    _compiler.types.variableDeclarator(
    identifier,
    isRepeated ? _compiler.types.arrayExpression([]) : _compiler.types.nullLiteral())]));



    parentPath.pushContainer(
    "attributes",
    _compiler.types.markoAttribute(targetProperty, identifier));

  }

  if (isRepeated) {
    tag.replaceWith(
    (0, _withPreviousLocation.default)(
    _compiler.types.expressionStatement(
    _compiler.types.callExpression(
    _compiler.types.memberExpression(identifier, _compiler.types.identifier("push")),
    [getAttrTagObject(tag)])),


    node));


  } else {
    tag.replaceWith(
    (0, _withPreviousLocation.default)(
    _compiler.types.expressionStatement(
    _compiler.types.assignmentExpression(
    "=",
    identifier,
    _compiler.types.callExpression(
    (0, _babelUtils.importDefault)(
    tag.hub.file,
    "marko/src/runtime/helpers/repeatable.js",
    "marko_repeatable"),

    [identifier, getAttrTagObject(tag)]))),



    node));


  }
}

function getAttrTagObject(tag) {
  const attrs = (0, _util.getAttrs)(tag);
  const iteratorProp = _compiler.types.objectProperty(
  _compiler.types.memberExpression(_compiler.types.identifier("Symbol"), _compiler.types.identifier("iterator")),
  (0, _babelUtils.importDefault)(
  tag.hub.file,
  "marko/src/runtime/helpers/self-iterator.js",
  "marko_self_iterator"),

  true);


  if (_compiler.types.isNullLiteral(attrs)) {
    return _compiler.types.objectExpression([iteratorProp]);
  }

  if (_compiler.types.isObjectExpression(attrs)) {
    attrs.properties.push(iteratorProp);
    return attrs;
  }

  return _compiler.types.objectExpression([iteratorProp, _compiler.types.spreadElement(attrs)]);
}

function isAttributeTagChild(tag) {
  if ((0, _babelUtils.isAttributeTag)(tag)) {
    return true;
  }

  if ((0, _babelUtils.isTransparentTag)(tag)) {
    const body = tag.get("body").get("body");
    return isAttributeTagChild(body[body.length - 1]);
  }

  return false;
}
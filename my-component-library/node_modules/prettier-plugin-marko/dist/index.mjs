// src/index.ts
import { resolve } from "path";
import { createRequire } from "module";
import {
  doc as doc5,
  getFileInfo
} from "prettier";
import { compileSync, types as t } from "@marko/compiler";

// src/constants.ts
var enclosedNodeTypeReg = /^(?:Identifier|.*Literal|(?:Object|Array|Parenthesized|Record|Tuple)Expression)$/;
var styleReg = /^style((?:\.[^\s\\/:*?"<>|({]+)+)?\s*\{?/;
var voidHTMLReg = /^(?:area|b(?:ase|r)|col|embed|hr|i(?:mg|nput)|keygen|link|meta|param|source|track|wbr)$/;
var shorthandIdOrClassReg = /^[a-zA-Z0-9_$][a-zA-Z0-9_$-]*(?:\s+[a-zA-Z0-9_$][a-zA-Z0-9_$-]*)*$/;
var preserveSpaceTagsReg = /^(?:textarea|pre)$/;

// src/utils/loc-to-pos.ts
function locToPos(loc, opts) {
  const { markoLinePositions } = opts;
  return markoLinePositions[loc.line - 1] + loc.column + (loc.line === 1 ? 0 : 1);
}

// src/utils/call-embed.ts
function callEmbed(print, path, mode, code) {
  const node = path.getValue();
  if (!code.trim()) {
    return "";
  }
  node._embed = {
    type: "_MarkoEmbed",
    mode,
    code,
    loc: void 0
  };
  try {
    return path.call(print, "_embed");
  } finally {
    node._embed = void 0;
  }
}

// src/utils/is-text-like.ts
function isTextLike(node, parent) {
  if (isText(node)) {
    return true;
  } else if (node.type === "MarkoComment") {
    const body = parent.type === "Program" ? parent.body : parent.body.body;
    const i = body.indexOf(node);
    let j = i;
    while (j > 0) {
      const check = body[--j];
      if (isText(check))
        return true;
      else if (check.type !== "MarkoComment")
        break;
    }
    j = i;
    while (j < body.length - 1) {
      const check = body[++j];
      if (isText(check))
        return true;
      else if (check.type !== "MarkoComment")
        break;
    }
  }
  return false;
}
function isText(node) {
  return node.type === "MarkoText" || node.type === "MarkoPlaceholder";
}

// src/utils/with-line-if-needed.ts
import { doc } from "prettier";
var { builders: b } = doc;
function withLineIfNeeded(node, opts, doc6) {
  const { originalText } = opts;
  let pos = locToPos(node.loc.start, opts);
  let count = 0;
  while (--pos >= 0) {
    let char = originalText[pos];
    if (char === "\n") {
      if (++count === 2) {
        while (--pos >= 0) {
          char = originalText[pos];
          if (char !== "\n" && char !== "	" && char !== "\r" && char !== " ") {
            return [b.hardline, doc6];
          }
        }
        return doc6;
      }
    } else if (char !== "	" && char !== "\r" && char !== " ") {
      break;
    }
  }
  return doc6;
}

// src/utils/with-block-if-needed.ts
import { doc as doc2 } from "prettier";

// src/utils/outer-code-matches.ts
var enclosedPatterns = [];
enclosedPatterns.push(
  {
    // Ignored
    match: /[a-z0-9_$#@.]+/iy
  },
  {
    // Line comments
    match: /\/\/.*$/y
  },
  {
    // Multi line comments
    match: /\/\*.*?\*\//y
  },
  {
    // Parens
    match: /\(/y,
    patterns: enclosedPatterns,
    until: /\)/y
  },
  {
    // Braces
    match: /{/y,
    patterns: enclosedPatterns,
    until: /}/y
  },
  {
    // Brackets
    match: /\[/y,
    patterns: enclosedPatterns,
    until: /]/y
  },
  {
    // Single quote string
    match: /'(?:\\.|[^'\\]+)*'/y
  },
  {
    // Double quote string
    match: /"(?:\\.|[^"\\]+)*"/y
  },
  {
    // Template literal
    match: /`/y,
    patterns: [
      {
        // Content
        match: /\\.|\$(?!{)|[^`\\$]+/y
      },
      {
        // Expressions
        match: /\${/y,
        patterns: enclosedPatterns,
        until: /}/y
      }
    ],
    until: /`/y
  },
  {
    // RegExp
    match: /\/(?:\\.|\[(?:\\.|[^\]\\]+)\]|[^[/\\])+\/[a-z]*/iy
  }
);
var unenclosedPatterns = [
  {
    // Word operators
    match: /(?<=\b)\s*(?:as|in(?:stanceof)?|new|void|delete|keyof|typeof)\s+/y
  },
  {
    // Symbol operators
    match: /\s*(?:[\^~%!]|\+{1,2}|\*{1,2}|-(?:-(?!\s))?|&{1,2}|\|{1,2}|!={0,2}|===?|<{2,3}|>{2,3}|<=?|>=)\s*/y
  }
].concat(enclosedPatterns);
function outerCodeMatches(str, test, enclosed) {
  const stack = [
    {
      until: test,
      patterns: enclosed ? enclosedPatterns : unenclosedPatterns
    }
  ];
  let pos = 0;
  do {
    const { until, patterns } = stack[stack.length - 1];
    outer:
      while (pos < str.length) {
        for (const pattern of patterns) {
          pattern.match.lastIndex = pos;
          if (pattern.match.test(str)) {
            pos = pattern.match.lastIndex;
            if (pattern.until) {
              stack.push(pattern);
              break outer;
            } else {
              continue outer;
            }
          }
        }
        until.lastIndex = pos;
        if (until.test(str)) {
          pos = until.lastIndex;
          if (stack.length === 1)
            return true;
          stack.pop();
          break;
        }
        pos++;
      }
  } while (pos < str.length && stack.length);
  return false;
}

// src/utils/with-block-if-needed.ts
var { builders: b2 } = doc2;
function withBlockIfNeeded(nodes, opts, getDocs) {
  if (nodes.length > 1 || !enclosedNodeTypeReg.test(nodes[0].type) && outerCodeMatches(
    doc2.printer.printDocToString(getDocs(), {
      ...opts,
      printWidth: 0
    }).formatted,
    /[\n\r]/y
  )) {
    return [
      b2.indent([b2.ifBreak(["{", b2.line]), b2.join(b2.hardline, getDocs())]),
      b2.ifBreak([b2.line, "}"])
    ];
  }
  return getDocs();
}

// src/utils/with-parens-if-needed.ts
import { doc as doc3 } from "prettier";
var { builders: b3 } = doc3;
function withParensIfNeeded(node, opts, getValDoc) {
  if (!enclosedNodeTypeReg.test(node.type) && outerCodeMatches(
    doc3.printer.printDocToString(getValDoc(), {
      ...opts,
      printWidth: 0
    }).formatted,
    /\s|>/y,
    opts.markoAttrParen
  )) {
    return ["(", b3.indent([b3.softline, getValDoc()]), b3.softline, ")"];
  }
  return getValDoc();
}

// src/utils/as-literal-text-content.ts
import { doc as doc4 } from "prettier";
var { builders: b4 } = doc4;
var temp = [""];
function asLiteralTextContent(val) {
  let charPos = 0;
  let slotPos = 0;
  for (let i = 0, len = val.length; i < len; i++) {
    switch (val.charAt(i)) {
      case "\\":
        temp.push("\\\\");
        break;
      case "\n":
        temp.push(b4.literalline);
        break;
      default:
        continue;
    }
    temp[slotPos] = val.slice(charPos, i);
    slotPos = temp.push("") - 1;
    charPos = i + 1;
  }
  if (charPos) {
    const result = temp;
    result[slotPos] = val.slice(charPos);
    temp = [""];
    return result;
  } else {
    return val;
  }
}

// src/utils/get-original-code.ts
import generate from "@babel/generator";
function getOriginalCodeForNode(opts, node) {
  const literal = literalToString(node);
  if (literal !== void 0)
    return literal;
  const loc = node.loc;
  if (!loc) {
    return generate(node, {
      filename: opts.filepath,
      compact: false,
      comments: true,
      sourceMaps: false
    }).code;
  }
  return opts.originalText.slice(
    locToPos(loc.start, opts),
    locToPos(loc.end, opts)
  );
}
function getOriginalCodeForList(opts, sep, list) {
  return list.map((node) => getOriginalCodeForNode(opts, node)).join(sep);
}
function literalToString(node) {
  switch (node.type) {
    case "StringLiteral":
      return `"${node.value.replace(/(["\\])/g, "\\$1")}"`;
    case "NumericLiteral":
      return node.value.toString();
    case "BooleanLiteral":
      return node.value ? "true" : "false";
    case "NullLiteral":
      return "null";
  }
}

// src/index.ts
var defaultFilePath = resolve("index.marko");
var { builders: b5, utils } = doc5;
var identity = (val) => val;
var embeddedPlaceholderReg = /__EMBEDDED_PLACEHOLDER_(\d+)__/g;
var languages = [
  {
    name: "marko",
    aceMode: "text",
    parsers: ["marko"],
    aliases: ["markojs"],
    tmScope: "text.marko",
    codemirrorMode: "htmlmixed",
    vscodeLanguageIds: ["marko"],
    linguistLanguageId: 932782397,
    codemirrorMimeType: "text/html",
    extensions: [".marko"]
  }
];
var options = {
  markoSyntax: {
    since: "",
    type: "choice",
    default: "auto",
    category: "Marko",
    description: "Change output syntax between HTML mode, concise mode and auto.",
    choices: [
      {
        value: "auto",
        description: "Determine output syntax by the input syntax used."
      },
      {
        value: "html",
        description: "Force the output to use the HTML syntax."
      },
      {
        value: "concise",
        description: "Force the output to use the concise syntax."
      }
    ]
  },
  markoAttrParen: {
    since: "",
    type: "boolean",
    default: (() => {
      try {
        const rootRequire = createRequire(defaultFilePath);
        let compilerRequire;
        try {
          compilerRequire = createRequire(
            rootRequire.resolve("@marko/compiler")
          );
        } catch {
          compilerRequire = createRequire(rootRequire.resolve("marko"));
        }
        const [major, minor] = compilerRequire("htmljs-parser/package.json").version.split(".").map((v) => parseInt(v, 10));
        return major < 2 || major === 2 && minor < 11;
      } catch {
        return false;
      }
    })(),
    category: "Marko",
    description: "If enabled all attributes with unenclosed whitespace will be wrapped in parens."
  }
};
var parsers = {
  marko: {
    astFormat: "marko-ast",
    parse(text, _parsers, opts) {
      const { filepath = defaultFilePath } = opts;
      const { ast } = compileSync(`${text}
`, filepath, {
        ast: true,
        code: false,
        optimize: false,
        output: "source",
        sourceMaps: false,
        writeVersionComment: false,
        babelConfig: {
          caller: { name: "@marko/prettier" },
          babelrc: false,
          configFile: false,
          parserOpts: {
            allowUndeclaredExports: true,
            allowAwaitOutsideFunction: true,
            allowReturnOutsideFunction: true,
            allowImportExportEverywhere: true,
            plugins: ["exportDefaultFrom", "importAssertions"]
          }
        }
      });
      opts.originalText = text;
      opts.markoLinePositions = [0];
      opts.markoScriptParser = "babel";
      opts.markoPreservingSpace = false;
      for (let i = 0; i < text.length; i++) {
        if (text[i] === "\n") {
          opts.markoLinePositions.push(i);
        }
      }
      if (opts.markoSyntax === "auto") {
        opts.markoSyntax = "html";
        for (const childNode of ast.program.body) {
          if (t.isMarkoTag(childNode)) {
            if (t.isStringLiteral(childNode.name) && childNode.name.value === "style" && styleReg.exec(childNode.rawValue || "style")[0].endsWith("{")) {
              continue;
            }
            if (opts.originalText[locToPos(childNode.loc.start, opts)] !== "<") {
              opts.markoSyntax = "concise";
            }
            break;
          }
        }
      }
      return ast;
    },
    locStart() {
      return 0;
    },
    locEnd() {
      return 0;
    }
  }
};
var printers = {
  "marko-ast": {
    print(path, opts, print) {
      var _a, _b, _c, _d;
      const node = path.getValue();
      switch (node.type) {
        case "File":
          return path.call(print, "program");
        case "Program": {
          let text = [];
          const lastIndex = node.body.length - 1;
          const bodyDocs = [];
          path.each((child, i) => {
            const childNode = child.getValue();
            const isText2 = isTextLike(childNode, node);
            if (isText2) {
              text.push(print(child));
              if (i !== lastIndex)
                return;
            }
            if (text.length) {
              const textDoc = b5.group([
                "--",
                b5.line,
                b5.fill(text),
                b5.ifBreak([b5.softline, "--"])
              ]);
              if (isText2) {
                bodyDocs.push(textDoc);
              } else {
                text = [];
                bodyDocs.push(textDoc, b5.hardline, print(child));
              }
            } else {
              bodyDocs.push(print(child));
            }
          }, "body");
          return [b5.join(b5.hardline, bodyDocs), b5.hardline];
        }
        case "MarkoDocumentType":
          return `<!${node.value.replace(/\s+/g, " ").trim()}>`;
        case "MarkoDeclaration":
          return asLiteralTextContent(`<?${node.value}?>`);
        case "MarkoComment": {
          const start = (_a = node.loc) == null ? void 0 : _a.start;
          switch (start != null && opts.originalText[locToPos(start, opts) + 1]) {
            case "/":
              return [asLiteralTextContent(`//${node.value}`), b5.hardline];
            case "*":
              return asLiteralTextContent(`/*${node.value}*/`);
            default:
              return asLiteralTextContent(`<!--${node.value}-->`);
          }
        }
        case "MarkoCDATA":
          return asLiteralTextContent(`<![CDATA[${node.value}]]>`);
        case "MarkoTag": {
          const tagPath = path;
          const groupId = Symbol();
          const doc6 = [opts.markoSyntax === "html" ? "<" : ""];
          const { markoPreservingSpace } = opts;
          const literalTagName = t.isStringLiteral(node.name) ? node.name.value : "";
          const preserveSpace = markoPreservingSpace || (opts.markoPreservingSpace = preserveSpaceTagsReg.test(literalTagName));
          let embedMode;
          if (literalTagName) {
            if (literalTagName === "script") {
              embedMode = "script";
            } else if (literalTagName === "style") {
              const [startContent, lang = ".css"] = styleReg.exec(
                node.rawValue || literalTagName
              );
              embedMode = `style.${getFileInfo.sync(opts.filepath + lang).inferredParser}`;
              if (startContent.endsWith("{")) {
                const codeSartOffset = startContent.length;
                const codeEndOffset = node.rawValue.lastIndexOf("}");
                const code = node.rawValue.slice(
                  codeSartOffset,
                  codeEndOffset
                );
                return b5.group([
                  "style",
                  lang === ".css" ? "" : lang,
                  " {",
                  b5.indent([
                    b5.line,
                    callEmbed(print, tagPath, embedMode, code)
                  ]),
                  b5.line,
                  "}"
                ]);
              }
            }
            doc6.push(literalTagName);
          } else {
            doc6.push(
              b5.group([
                "${",
                b5.indent([b5.softline, tagPath.call(print, "name")]),
                b5.softline,
                "}"
              ])
            );
          }
          const shorthandIndex = doc6.push("") - 1;
          if (node.var) {
            doc6.push(
              "/",
              callEmbed(
                print,
                tagPath,
                "var",
                getOriginalCodeForNode(opts, node.var)
              )
            );
          }
          if ((_b = node.arguments) == null ? void 0 : _b.length) {
            doc6.push(
              b5.group([
                "(",
                b5.indent([
                  b5.softline,
                  b5.join([",", b5.line], tagPath.map(print, "arguments")),
                  opts.trailingComma ? b5.ifBreak(",") : ""
                ]),
                b5.softline,
                ")"
              ])
            );
          }
          if (node.body.params.length) {
            doc6.push(
              b5.group([
                "|",
                callEmbed(
                  print,
                  tagPath,
                  "params",
                  getOriginalCodeForList(opts, ",", node.body.params)
                ),
                "|"
              ])
            );
          }
          if (node.attributes.length) {
            const attrsDoc = [];
            tagPath.each((childPath) => {
              const childNode = childPath.getValue();
              if (t.isMarkoAttribute(childNode) && (childNode.name === "class" || childNode.name === "id")) {
                if ((literalTagName === "style" || opts.markoSyntax === "concise") && t.isStringLiteral(childNode.value) && !childNode.modifier && shorthandIdOrClassReg.test(childNode.value.value)) {
                  const symbol = childNode.name === "class" ? "." : "#";
                  doc6[shorthandIndex] += symbol + childNode.value.value.split(/ +/).join(symbol);
                } else {
                  childNode.value.loc = null;
                  attrsDoc.push(print(childPath));
                }
              } else if (childNode.default) {
                doc6.push(print(childPath));
              } else {
                attrsDoc.push(print(childPath));
              }
            }, "attributes");
            if (attrsDoc.length) {
              if (attrsDoc.length === 1) {
                doc6.push(" ", attrsDoc[0]);
              } else {
                doc6.push(
                  b5.group([
                    opts.markoSyntax === "concise" ? b5.ifBreak(" [") : "",
                    b5.indent([b5.line, b5.join(b5.line, attrsDoc)]),
                    opts.markoSyntax === "concise" ? b5.ifBreak([b5.line, "]"]) : b5.ifBreak(b5.line)
                  ])
                );
              }
            }
          }
          if (voidHTMLReg.test(literalTagName)) {
            if (opts.markoSyntax === "html")
              doc6.push(">");
          } else if (node.body.body.length) {
            const lastIndex = node.body.body.length - 1;
            const bodyDocs = [];
            let textOnly = true;
            if (embedMode) {
              let placeholderId = 0;
              const placeholders = [];
              let embeddedCode = "";
              tagPath.each(
                (child) => {
                  const node2 = child.getValue();
                  if (node2.type === "MarkoText") {
                    embeddedCode += node2.value;
                  } else {
                    embeddedCode += `__EMBEDDED_PLACEHOLDER_${placeholderId++}__`;
                    placeholders.push(print(child));
                  }
                },
                "body",
                "body"
              );
              const embeddedDoc = replaceEmbeddedPlaceholders(
                callEmbed(print, tagPath, embedMode, embeddedCode),
                placeholders
              );
              bodyDocs.push(
                b5.group([
                  opts.markoSyntax === "html" ? "" : b5.ifBreak("--", " --", { groupId }),
                  opts.markoSyntax === "html" ? "" : b5.line,
                  embeddedDoc,
                  opts.markoSyntax === "html" ? "" : b5.ifBreak([b5.softline, "--"])
                ])
              );
            } else {
              let textDocs = [];
              tagPath.each(
                (child, i) => {
                  const childNode = child.getValue();
                  const isText2 = isTextLike(childNode, node);
                  if (isText2) {
                    textDocs.push(print(child));
                    if (i !== lastIndex)
                      return;
                  } else {
                    textOnly = false;
                  }
                  if (textDocs.length) {
                    const isFirst = !bodyDocs.length;
                    bodyDocs.push(
                      b5.group([
                        opts.markoSyntax === "html" ? "" : isFirst ? b5.ifBreak("--", " --", { groupId }) : "--",
                        opts.markoSyntax === "html" ? "" : preserveSpace ? b5.hardline : b5.line,
                        preserveSpace ? textDocs : b5.fill(textDocs),
                        opts.markoSyntax === "html" ? "" : b5.ifBreak([b5.softline, "--"])
                      ])
                    );
                    if (!isText2) {
                      textDocs = [];
                      bodyDocs.push(print(child));
                    }
                  } else {
                    bodyDocs.push(print(child));
                  }
                },
                "body",
                "body"
              );
            }
            const joinSep = (preserveSpace || !textOnly) && (opts.markoSyntax === "concise" || node.body.body.some((child) => child.type === "MarkoScriptlet")) ? b5.hardline : preserveSpace ? "" : b5.softline;
            const wrapSep = !preserveSpace && opts.markoSyntax === "html" && (node.var || node.body.params.length || ((_c = node.arguments) == null ? void 0 : _c.length) || node.attributes.length || node.body.body.some((child) => !isTextLike(child, node))) ? b5.hardline : joinSep;
            if (opts.markoSyntax === "html") {
              doc6.push(">");
            }
            if (joinSep || wrapSep) {
              doc6.push(b5.indent([wrapSep, b5.join(joinSep, bodyDocs)]));
              if (opts.markoSyntax === "html") {
                doc6.push(wrapSep);
              }
            } else {
              doc6.push(...bodyDocs);
            }
            if (opts.markoSyntax === "html") {
              doc6.push(`</${literalTagName}>`);
            }
          } else if (opts.markoSyntax === "html") {
            doc6.push("/>");
          }
          opts.markoPreservingSpace = markoPreservingSpace;
          return withLineIfNeeded(node, opts, b5.group(doc6, { id: groupId }));
        }
        case "MarkoAttribute": {
          const attrPath = path;
          const doc6 = [];
          const { value } = node;
          if (!node.default) {
            doc6.push(node.name);
            if (node.modifier) {
              doc6.push(`:${node.modifier}`);
            }
            if ((_d = node.arguments) == null ? void 0 : _d.length) {
              doc6.push(
                b5.group([
                  "(",
                  b5.indent([
                    b5.softline,
                    b5.join([",", b5.line], attrPath.map(print, "arguments")),
                    opts.trailingComma ? b5.ifBreak(",") : ""
                  ]),
                  b5.softline,
                  ")"
                ])
              );
            }
          }
          if (node.default || !t.isBooleanLiteral(value, { value: true })) {
            if (t.isFunctionExpression(value) && !(value.id || value.async || value.generator)) {
              doc6.push(
                b5.group([
                  "(",
                  value.params.length ? callEmbed(
                    print,
                    attrPath,
                    "params",
                    getOriginalCodeForList(opts, ",", value.params)
                  ) : "",
                  ")"
                ]),
                b5.group([
                  " {",
                  b5.indent([
                    b5.line,
                    b5.join(
                      b5.hardline,
                      attrPath.map(print, "value", "body", "body")
                    )
                  ]),
                  b5.line,
                  "}"
                ])
              );
            } else {
              doc6.push(
                node.bound ? ":=" : "=",
                b5.group(
                  enclosedNodeTypeReg.test(node.type) ? attrPath.call(print, "value") : withParensIfNeeded(
                    value,
                    opts,
                    () => attrPath.call(print, "value")
                  )
                )
              );
            }
          }
          return doc6;
        }
        case "MarkoSpreadAttribute": {
          return ["..."].concat(
            withParensIfNeeded(
              node.value,
              opts,
              () => path.call(print, "value")
            )
          );
        }
        case "MarkoPlaceholder":
          return [
            node.escape ? "${" : "$!{",
            path.call(print, "value"),
            "}"
          ];
        case "MarkoScriptlet":
          return withLineIfNeeded(
            node.body[0],
            opts,
            b5.group([
              node.static ? "static " : "$ ",
              withBlockIfNeeded(node.body, opts, () => path.map(print, "body"))
            ])
          );
        case "MarkoText": {
          const quote = opts.singleQuote ? "'" : '"';
          const escapedSpace = `\${${quote} ${quote}}`;
          const { value } = node;
          if (value === " " && (opts.markoSyntax === "concise" || path.getParentNode().type === "Program")) {
            return escapedSpace;
          }
          const breakValue = value.replace(/^ | $/g, escapedSpace);
          if (breakValue === value) {
            return asLiteralTextContent(value);
          }
          return b5.ifBreak(
            asLiteralTextContent(breakValue),
            asLiteralTextContent(value)
          );
        }
        default:
          throw new Error(`Unknown node type in Marko template: ${node.type}`);
      }
    },
    embed(path, print, toDoc, opts) {
      const node = path.getValue();
      switch (node.type) {
        case "_MarkoEmbed":
          switch (node.mode) {
            case "var": {
              return tryPrintEmbed(
                `var ${node.code}=_`,
                opts.markoScriptParser,
                (doc6) => {
                  const contents = doc6[0].contents[1].contents;
                  for (let i = contents.length; i--; ) {
                    const item = contents[i];
                    if (typeof item === "string") {
                      const match = /\s*=\s*$/.exec(item);
                      if (match) {
                        contents[i] = item.slice(0, -match[0].length);
                        contents.length = i + 1;
                        break;
                      }
                    }
                  }
                  return contents;
                }
              );
            }
            case "params": {
              return tryPrintEmbed(
                `(${node.code})=>_`,
                "__js_expression",
                (doc6) => {
                  const { contents } = doc6.contents[0];
                  if (Array.isArray(contents) && contents[0].startsWith("(")) {
                    contents[0] = contents[0].slice(1);
                    contents[contents.length - 1] = contents[contents.length - 1].slice(0, -1);
                  }
                  return contents;
                }
              );
            }
            case "script":
              return tryPrintEmbed(node.code, opts.markoScriptParser);
            default: {
              if (!node.mode.startsWith("style.")) {
                return [b5.trim, asLiteralTextContent(node.code)];
              }
              return tryPrintEmbed(node.code, node.mode.slice("style.".length));
            }
          }
        case "MarkoClass":
          return toDoc(
            `class ${getOriginalCodeForNode(opts, node.body)}`,
            { parser: "__js_expression" },
            { stripTrailingHardline: true }
          );
        case "File":
        case "Program":
          return null;
        default:
          if (node.type.startsWith("Marko")) {
            return null;
          }
      }
      if (t.isStatement(node)) {
        return tryPrintEmbed(
          getOriginalCodeForNode(opts, node),
          opts.markoScriptParser
        );
      } else {
        return tryPrintEmbed(
          getOriginalCodeForNode(opts, node),
          "__js_expression"
        );
      }
      function tryPrintEmbed(code, parser, normalize = identity) {
        try {
          return normalize(
            toDoc(code, { parser }, { stripTrailingHardline: true })
          );
        } catch {
          return [b5.trim, asLiteralTextContent(code)];
        }
      }
    }
  }
};
function replaceEmbeddedPlaceholders(doc6, placeholders) {
  if (!placeholders.length)
    return doc6;
  return utils.mapDoc(doc6, (cur) => {
    if (typeof cur === "string") {
      let match = embeddedPlaceholderReg.exec(cur);
      if (match) {
        const replacementDocs = [];
        let index = 0;
        do {
          const placeholderIndex = +match[1];
          if (index !== match.index) {
            replacementDocs.push(cur.slice(index, match.index));
          }
          replacementDocs.push(placeholders[placeholderIndex]);
          index = match.index + match[0].length;
        } while (match = embeddedPlaceholderReg.exec(cur));
        if (index !== cur.length) {
          replacementDocs.push(cur.slice(index));
        }
        if (replacementDocs.length === 1) {
          return replacementDocs[0];
        }
        return replacementDocs;
      }
    }
    return cur;
  });
}
export {
  languages,
  options,
  parsers,
  printers
};

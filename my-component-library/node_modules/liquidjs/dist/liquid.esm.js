/*
 * liquidjs@9.6.0, https://github.com/harttle/liquidjs
 * (c) 2016-2019 harttle
 * Released under the MIT License.
 */
class Drop {
    valueOf() {
        return undefined;
    }
    liquidMethodMissing(key) {
        return undefined;
    }
}

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

const toStr = Object.prototype.toString;
/*
 * Checks if value is classified as a String primitive or object.
 * @param {any} value The value to check.
 * @return {Boolean} Returns true if value is a string, else false.
 */
function isString(value) {
    return toStr.call(value) === '[object String]';
}
function isFunction(value) {
    return typeof value === 'function';
}
function stringify(value) {
    value = toValue(value);
    return isNil(value) ? '' : String(value);
}
function toValue(value) {
    return value instanceof Drop ? value.valueOf() : value;
}
function isNumber(value) {
    return typeof value === 'number';
}
function toLiquid(value) {
    if (value && isFunction(value.toLiquid))
        return toLiquid(value.toLiquid());
    return value;
}
function isNil(value) {
    return value === null || value === undefined;
}
function isArray(value) {
    // be compatible with IE 8
    return toStr.call(value) === '[object Array]';
}
/*
 * Iterates over own enumerable string keyed properties of an object and invokes iteratee for each property.
 * The iteratee is invoked with three arguments: (value, key, object).
 * Iteratee functions may exit iteration early by explicitly returning false.
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @return {Object} Returns object.
 */
function forOwn(object, iteratee) {
    object = object || {};
    for (const k in object) {
        if (object.hasOwnProperty(k)) {
            if (iteratee(object[k], k, object) === false)
                break;
        }
    }
    return object;
}
function last(arr) {
    return arr[arr.length - 1];
}
/*
 * Checks if value is the language type of Object.
 * (e.g. arrays, functions, objects, regexes, new Number(0), and new String(''))
 * @param {any} value The value to check.
 * @return {Boolean} Returns true if value is an object, else false.
 */
function isObject(value) {
    const type = typeof value;
    return value !== null && (type === 'object' || type === 'function');
}
function range(start, stop, step = 1) {
    const arr = [];
    for (let i = start; i < stop; i += step) {
        arr.push(i);
    }
    return arr;
}
function padStart(str, length, ch = ' ') {
    return pad(str, length, ch, (str, ch) => ch + str);
}
function padEnd(str, length, ch = ' ') {
    return pad(str, length, ch, (str, ch) => str + ch);
}
function pad(str, length, ch, add) {
    str = String(str);
    let n = length - str.length;
    while (n-- > 0)
        str = add(str, ch);
    return str;
}
function identify(val) {
    return val;
}
function changeCase(str) {
    const hasLowerCase = [...str].some(ch => ch >= 'a' && ch <= 'z');
    return hasLowerCase ? str.toUpperCase() : str.toLowerCase();
}

class LiquidError extends Error {
    constructor(err, token) {
        super(err.message);
        this.originalError = err;
        this.token = token;
    }
    update() {
        const err = this.originalError;
        const context = mkContext(this.token);
        this.message = mkMessage(err.message, this.token);
        this.stack = this.message + '\n' + context +
            '\n' + this.stack + '\nFrom ' + err.stack;
    }
}
class TokenizationError extends LiquidError {
    constructor(message, token) {
        super(new Error(message), token);
        this.name = 'TokenizationError';
        super.update();
    }
}
class ParseError extends LiquidError {
    constructor(err, token) {
        super(err, token);
        this.name = 'ParseError';
        this.message = err.message;
        super.update();
    }
}
class RenderError extends LiquidError {
    constructor(err, tpl) {
        super(err, tpl.token);
        this.name = 'RenderError';
        this.message = err.message;
        super.update();
    }
    static is(obj) {
        return obj instanceof RenderError;
    }
}
class AssertionError extends Error {
    constructor(message) {
        super(message);
        this.name = 'AssertionError';
        this.message = message + '';
    }
}
function mkContext(token) {
    const lines = token.input.split('\n');
    const begin = Math.max(token.line - 2, 1);
    const end = Math.min(token.line + 3, lines.length);
    const context = range(begin, end + 1)
        .map(lineNumber => {
        const indicator = (lineNumber === token.line) ? '>> ' : '   ';
        const num = padStart(String(lineNumber), String(end).length);
        const text = lines[lineNumber - 1];
        return `${indicator}${num}| ${text}`;
    })
        .join('\n');
    return context;
}
function mkMessage(msg, token) {
    if (token.file)
        msg += `, file:${token.file}`;
    msg += `, line:${token.line}, col:${token.col}`;
    return msg;
}

function assert(predicate, message) {
    if (!predicate) {
        message = message || `expect ${predicate} to be true`;
        throw new AssertionError(message);
    }
}

const defaultOptions = {
    root: ['.'],
    cache: false,
    extname: '',
    dynamicPartials: true,
    trimTagRight: false,
    trimTagLeft: false,
    trimOutputRight: false,
    trimOutputLeft: false,
    greedy: true,
    tagDelimiterLeft: '{%',
    tagDelimiterRight: '%}',
    outputDelimiterLeft: '{{',
    outputDelimiterRight: '}}',
    strictFilters: false,
    strictVariables: false
};
function normalize(options) {
    options = options || {};
    if (options.hasOwnProperty('root')) {
        options.root = normalizeStringArray(options.root);
    }
    return options;
}
function applyDefault(options) {
    return Object.assign({}, defaultOptions, options);
}
function normalizeStringArray(value) {
    if (isArray(value))
        return value;
    if (isString(value))
        return [value];
    return [];
}

class Context {
    constructor(env = {}, opts, sync = false) {
        this.scopes = [{}];
        this.registers = {};
        this.sync = sync;
        this.opts = applyDefault(opts);
        this.environments = env;
    }
    getRegister(key, defaultValue = {}) {
        return (this.registers[key] = this.registers[key] || defaultValue);
    }
    setRegister(key, value) {
        return (this.registers[key] = value);
    }
    getAll() {
        return [this.environments, ...this.scopes]
            .reduce((ctx, val) => __assign(ctx, val), {});
    }
    get(path) {
        const paths = this.parseProp(path);
        const scope = this.findScope(paths[0]) || this.environments;
        return this.getFromScope(scope, paths);
    }
    getFromScope(scope, paths) {
        if (!isArray(paths))
            paths = this.parseProp(paths);
        return paths.reduce((scope, path) => {
            scope = readProperty(scope, path);
            if (isNil(scope) && this.opts.strictVariables) {
                throw new TypeError(`undefined variable: ${path}`);
            }
            return scope;
        }, scope);
    }
    push(ctx) {
        return this.scopes.push(ctx);
    }
    pop() {
        return this.scopes.pop();
    }
    front() {
        return this.scopes[0];
    }
    findScope(key) {
        for (let i = this.scopes.length - 1; i >= 0; i--) {
            const candidate = this.scopes[i];
            if (key in candidate) {
                return candidate;
            }
        }
        return null;
    }
    /*
     * Parse property access sequence from access string
     * @example
     * accessSeq("foo.bar")         // ['foo', 'bar']
     * accessSeq("foo['bar']")      // ['foo', 'bar']
     * accessSeq("foo['b]r']")      // ['foo', 'b]r']
     * accessSeq("foo[bar.coo]")    // ['foo', 'bar'], for bar.coo == 'bar'
     */
    parseProp(str) {
        str = String(str);
        const seq = [];
        let name = '';
        let j;
        let i = 0;
        while (i < str.length) {
            switch (str[i]) {
                case '[':
                    push();
                    const delemiter = str[i + 1];
                    if (/['"]/.test(delemiter)) { // foo["bar"]
                        j = str.indexOf(delemiter, i + 2);
                        assert(j !== -1, `unbalanced ${delemiter}: ${str}`);
                        name = str.slice(i + 2, j);
                        push();
                        i = j + 2;
                    }
                    else { // foo[bar.coo]
                        j = matchRightBracket(str, i + 1);
                        assert(j !== -1, `unbalanced []: ${str}`);
                        name = str.slice(i + 1, j);
                        if (!/^[+-]?\d+$/.test(name)) { // foo[bar] vs. foo[1]
                            name = String(this.get(name));
                        }
                        push();
                        i = j + 1;
                    }
                    break;
                case '.': // foo.bar, foo[0].bar
                    push();
                    i++;
                    break;
                default: // foo.bar
                    name += str[i++];
            }
        }
        push();
        if (!seq.length) {
            throw new TypeError(`invalid path:"${str}"`);
        }
        return seq;
        function push() {
            if (name.length)
                seq.push(name);
            name = '';
        }
    }
}
function readProperty(obj, key) {
    if (isNil(obj))
        return obj;
    obj = toLiquid(obj);
    if (obj instanceof Drop) {
        if (isFunction(obj[key]))
            return obj[key]();
        if (obj.hasOwnProperty(key))
            return obj[key];
        return obj.liquidMethodMissing(key);
    }
    if (key === 'size')
        return readSize(obj);
    if (key === 'first')
        return readFirst(obj);
    if (key === 'last')
        return readLast(obj);
    return obj[key];
}
function readFirst(obj) {
    if (isArray(obj))
        return obj[0];
    return obj['first'];
}
function readLast(obj) {
    if (isArray(obj))
        return obj[obj.length - 1];
    return obj['last'];
}
function readSize(obj) {
    if (isArray(obj) || isString(obj))
        return obj.length;
    return obj['size'];
}
function matchRightBracket(str, begin) {
    let stack = 1; // count of '[' - count of ']'
    for (let i = begin; i < str.length; i++) {
        if (str[i] === '[') {
            stack++;
        }
        if (str[i] === ']') {
            stack--;
            if (stack === 0) {
                return i;
            }
        }
    }
    return -1;
}

function domResolve(root, path) {
    const base = document.createElement('base');
    base.href = root;
    const head = document.getElementsByTagName('head')[0];
    head.insertBefore(base, head.firstChild);
    const a = document.createElement('a');
    a.href = path;
    const resolved = a.href;
    head.removeChild(base);
    return resolved;
}
function resolve(root, filepath, ext) {
    if (root.length && last(root) !== '/')
        root += '/';
    const url = domResolve(root, filepath);
    return url.replace(/^(\w+:\/\/[^/]+)(\/[^?]+)/, (str, origin, path) => {
        const last = path.split('/').pop();
        if (/\.\w+$/.test(last))
            return str;
        return origin + path + ext;
    });
}
async function readFile(url) {
    return new Promise((resolve, reject) => {
        const xhr = new XMLHttpRequest();
        xhr.onload = () => {
            if (xhr.status >= 200 && xhr.status < 300) {
                resolve(xhr.responseText);
            }
            else {
                reject(new Error(xhr.statusText));
            }
        };
        xhr.onerror = () => {
            reject(new Error('An error occurred whilst receiving the response.'));
        };
        xhr.open('GET', url);
        xhr.send();
    });
}
function readFileSync(url) {
    const xhr = new XMLHttpRequest();
    xhr.open('GET', url, false);
    xhr.send();
    if (xhr.status < 200 || xhr.status >= 300) {
        throw new Error(xhr.statusText);
    }
    return xhr.responseText;
}
async function exists() {
    return true;
}
function existsSync() {
    return true;
}
var fs = { readFile, resolve, exists, existsSync, readFileSync };

class Token {
    constructor(raw, input, line, col, file) {
        this.trimLeft = false;
        this.trimRight = false;
        this.type = 'notset';
        this.col = col;
        this.line = line;
        this.raw = raw;
        this.value = raw;
        this.input = input;
        this.file = file;
    }
}

class DelimitedToken extends Token {
    constructor(raw, value, input, line, pos, trimLeft, trimRight, file) {
        super(raw, input, line, pos, file);
        const tl = value[0] === '-';
        const tr = last(value) === '-';
        this.value = value
            .slice(tl ? 1 : 0, tr ? -1 : value.length)
            .trim();
        this.trimLeft = tl || trimLeft;
        this.trimRight = tr || trimRight;
    }
}

// quote related
const singleQuoted = /'[^']*'/;
const doubleQuoted = /"[^"]*"/;
const quoted = new RegExp(`${singleQuoted.source}|${doubleQuoted.source}`);
// basic types
const number = /[+-]?(?:\d+\.?\d*|\.?\d+)/;
const bool = /true|false/;
// property access
const identifier = /[\w-]+[?]?/;
const subscript = new RegExp(`\\[(?:${quoted.source}|[\\w-\\.]+)\\]`);
const literal = new RegExp(`(?:${quoted.source}|${bool.source}|${number.source})`);
const variable = new RegExp(`${identifier.source}(?:\\.${identifier.source}|${subscript.source})*`);
// range related
const rangeLimit = new RegExp(`(?:${variable.source}|${number.source})`);
const range$1 = new RegExp(`\\(${rangeLimit.source}\\.\\.${rangeLimit.source}\\)`);
const rangeCapture = new RegExp(`\\((${rangeLimit.source})\\.\\.(${rangeLimit.source})\\)`);
const value = new RegExp(`(?:${variable.source}|${literal.source}|${range$1.source})`);
// hash related
const hash = new RegExp(`(?:${identifier.source})\\s*:\\s*(?:${value.source})`);
const hashCapture = new RegExp(`(${identifier.source})\\s*:\\s*(${value.source})`, 'g');
// full match
const tagLine = new RegExp(`^\\s*(${identifier.source})\\s*([\\s\\S]*?)\\s*$`);
const quotedLine = new RegExp(`^${quoted.source}$`);
const rangeLine = new RegExp(`^${rangeCapture.source}$`);

class TagToken extends DelimitedToken {
    constructor(raw, value, input, line, pos, options, file) {
        super(raw, value, input, line, pos, options.trimTagLeft, options.trimTagRight, file);
        this.type = 'tag';
        const match = this.value.match(tagLine);
        if (!match) {
            throw new TokenizationError(`illegal tag syntax`, this);
        }
        this.name = match[1];
        this.args = match[2];
    }
    static is(token) {
        return token.type === 'tag';
    }
}

class HTMLToken extends Token {
    constructor(str, input, line, col, file) {
        super(str, input, line, col, file);
        this.type = 'html';
        this.value = str;
    }
    static is(token) {
        return token.type === 'html';
    }
}

function whiteSpaceCtrl(tokens, options) {
    options = Object.assign({ greedy: true }, options);
    let inRaw = false;
    for (let i = 0; i < tokens.length; i++) {
        const token = tokens[i];
        if (!inRaw && token.trimLeft) {
            trimLeft(tokens[i - 1], options.greedy);
        }
        if (TagToken.is(token)) {
            if (token.name === 'raw')
                inRaw = true;
            else if (token.name === 'endraw')
                inRaw = false;
        }
        if (!inRaw && token.trimRight) {
            trimRight(tokens[i + 1], options.greedy);
        }
    }
}
function trimLeft(token, greedy) {
    if (!token || !HTMLToken.is(token))
        return;
    const rLeft = greedy ? /\s+$/g : /[\t\r ]*$/g;
    token.value = token.value.replace(rLeft, '');
}
function trimRight(token, greedy) {
    if (!token || !HTMLToken.is(token))
        return;
    const rRight = greedy ? /^\s+/g : /^[\t\r ]*\n?/g;
    token.value = token.value.replace(rRight, '');
}

class OutputToken extends DelimitedToken {
    constructor(raw, value, input, line, pos, options, file) {
        super(raw, value, input, line, pos, options.trimOutputLeft, options.trimOutputRight, file);
        this.type = 'output';
    }
    static is(token) {
        return token.type === 'output';
    }
}

function flatten(str) {
    return str;
}

var ParseState;
(function (ParseState) {
    ParseState[ParseState["HTML"] = 0] = "HTML";
    ParseState[ParseState["OUTPUT"] = 1] = "OUTPUT";
    ParseState[ParseState["TAG"] = 2] = "TAG";
})(ParseState || (ParseState = {}));
class Tokenizer {
    constructor(options) {
        this.options = applyDefault(options);
    }
    tokenize(input, file) {
        const tokens = [];
        const { tagDelimiterLeft, tagDelimiterRight, outputDelimiterLeft, outputDelimiterRight } = this.options;
        let p = 0;
        let curLine = 1;
        let state = ParseState.HTML;
        let buffer = '';
        let lineBegin = 0;
        let line = 1;
        let col = 1;
        while (p < input.length) {
            if (input[p] === '\n') {
                curLine++;
                lineBegin = p + 1;
            }
            if (state === ParseState.HTML) {
                if (input.substr(p, outputDelimiterLeft.length) === outputDelimiterLeft) {
                    if (buffer)
                        tokens.push(new HTMLToken(flatten(buffer), input, line, col, file));
                    buffer = outputDelimiterLeft;
                    line = curLine;
                    col = p - lineBegin + 1;
                    p += outputDelimiterLeft.length;
                    state = ParseState.OUTPUT;
                    continue;
                }
                else if (input.substr(p, tagDelimiterLeft.length) === tagDelimiterLeft) {
                    if (buffer)
                        tokens.push(new HTMLToken(flatten(buffer), input, line, col, file));
                    buffer = tagDelimiterLeft;
                    line = curLine;
                    col = p - lineBegin + 1;
                    p += tagDelimiterLeft.length;
                    state = ParseState.TAG;
                    continue;
                }
            }
            else if (state === ParseState.OUTPUT &&
                input.substr(p, outputDelimiterRight.length) === outputDelimiterRight) {
                buffer += outputDelimiterRight;
                tokens.push(new OutputToken(flatten(buffer), buffer.slice(outputDelimiterLeft.length, -outputDelimiterRight.length), input, line, col, this.options, file));
                p += outputDelimiterRight.length;
                buffer = '';
                line = curLine;
                col = p - lineBegin + 1;
                state = ParseState.HTML;
                continue;
            }
            else if (input.substr(p, tagDelimiterRight.length) === tagDelimiterRight) {
                buffer += tagDelimiterRight;
                tokens.push(new TagToken(flatten(buffer), buffer.slice(tagDelimiterLeft.length, -tagDelimiterRight.length), input, line, col, this.options, file));
                p += tagDelimiterRight.length;
                buffer = '';
                line = curLine;
                col = p - lineBegin + 1;
                state = ParseState.HTML;
                continue;
            }
            buffer += input[p++];
        }
        if (state !== ParseState.HTML) {
            const t = state === ParseState.OUTPUT ? 'output' : 'tag';
            const str = buffer.length > 16 ? buffer.slice(0, 13) + '...' : buffer;
            throw new TokenizationError(`${t} "${str}" not closed`, new Token(flatten(buffer), input, line, col, file));
        }
        if (buffer)
            tokens.push(new HTMLToken(flatten(buffer), input, line, col, file));
        whiteSpaceCtrl(tokens, this.options);
        return tokens;
    }
}

class Emitter {
    constructor() {
        this.html = '';
        this.break = false;
        this.continue = false;
    }
    write(html) {
        this.html += html;
    }
}

class Render {
    *renderTemplates(templates, ctx, emitter = new Emitter()) {
        for (const tpl of templates) {
            try {
                const html = yield tpl.render(ctx, emitter);
                html && emitter.write(html);
                if (emitter.break || emitter.continue)
                    break;
            }
            catch (e) {
                const err = RenderError.is(e) ? e : new RenderError(e, tpl);
                throw err;
            }
        }
        return emitter.html;
    }
}

class Template {
    constructor(token) {
        this.token = token;
    }
}

class EmptyDrop extends Drop {
    equals(value) {
        if (isString(value) || isArray(value))
            return value.length === 0;
        if (isObject(value))
            return Object.keys(value).length === 0;
        return false;
    }
    gt() {
        return false;
    }
    geq() {
        return false;
    }
    lt() {
        return false;
    }
    leq() {
        return false;
    }
    valueOf() {
        return '';
    }
}

class BlankDrop extends EmptyDrop {
    equals(value) {
        if (value === false)
            return true;
        if (isNil(toValue(value)))
            return true;
        if (isString(value))
            return /^\s*$/.test(value);
        return super.equals(value);
    }
}

class NullDrop extends Drop {
    equals(value) {
        return isNil(toValue(value)) || value instanceof BlankDrop;
    }
    gt() {
        return false;
    }
    geq() {
        return false;
    }
    lt() {
        return false;
    }
    leq() {
        return false;
    }
    valueOf() {
        return null;
    }
}

function parseLiteral(str) {
    str = str.trim();
    if (str === 'true')
        return true;
    if (str === 'false')
        return false;
    if (str === 'nil' || str === 'null')
        return new NullDrop();
    if (str === 'empty')
        return new EmptyDrop();
    if (str === 'blank')
        return new BlankDrop();
    if (!isNaN(Number(str)))
        return Number(str);
    if ((str[0] === '"' || str[0] === "'") && str[0] === last(str))
        return str.slice(1, -1);
}

class Value {
    constructor(str) {
        this.str = str;
    }
    evaluate(ctx) {
        const literalValue = parseLiteral(this.str);
        if (literalValue !== undefined) {
            return literalValue;
        }
        return ctx.get(this.str);
    }
    value(ctx) {
        return toValue(this.evaluate(ctx));
    }
}

function isRange(token) {
    return token[0] === '(' && token[token.length - 1] === ')';
}
function* rangeValue(token, ctx) {
    let match;
    if ((match = token.match(rangeLine))) {
        const low = yield new Value(match[1]).value(ctx);
        const high = yield new Value(match[2]).value(ctx);
        return range(+low, +high + 1);
    }
}

function isComparable(arg) {
    return arg && isFunction(arg.equals);
}

function isTruthy(val) {
    return !isFalsy(val);
}
function isFalsy(val) {
    return val === false || undefined === val || val === null;
}

const precedence = {
    '==': 1,
    '!=': 1,
    '>': 1,
    '<': 1,
    '>=': 1,
    '<=': 1,
    'contains': 1,
    'and': 0,
    'or': 0
};
const operatorImpls = {
    '==': (l, r) => {
        if (isComparable(l))
            return l.equals(r);
        if (isComparable(r))
            return r.equals(l);
        return l === r;
    },
    '!=': (l, r) => {
        if (isComparable(l))
            return !l.equals(r);
        if (isComparable(r))
            return !r.equals(l);
        return l !== r;
    },
    '>': (l, r) => {
        if (isComparable(l))
            return l.gt(r);
        if (isComparable(r))
            return r.lt(l);
        return l > r;
    },
    '<': (l, r) => {
        if (isComparable(l))
            return l.lt(r);
        if (isComparable(r))
            return r.gt(l);
        return l < r;
    },
    '>=': (l, r) => {
        if (isComparable(l))
            return l.geq(r);
        if (isComparable(r))
            return r.leq(l);
        return l >= r;
    },
    '<=': (l, r) => {
        if (isComparable(l))
            return l.leq(r);
        if (isComparable(r))
            return r.geq(l);
        return l <= r;
    },
    'contains': (l, r) => {
        return l && isFunction(l.indexOf) ? l.indexOf(r) > -1 : false;
    },
    'and': (l, r) => isTruthy(l) && isTruthy(r),
    'or': (l, r) => isTruthy(l) || isTruthy(r)
};
const list = Object.keys(precedence);
function isOperator(token) {
    return list.includes(token);
}

class Expression {
    constructor(str = '') {
        this.operands = [];
        this.postfix = [...toPostfix(str)];
    }
    *evaluate(ctx) {
        assert(ctx, 'unable to evaluate: context not defined');
        for (const token of this.postfix) {
            if (isOperator(token)) {
                this.evaluateOnce(token);
            }
            else if (isRange(token)) {
                this.operands.push(yield rangeValue(token, ctx));
            }
            else
                this.operands.push(yield new Value(token).evaluate(ctx));
        }
        return this.operands[0];
    }
    *value(ctx) {
        return toValue(yield this.evaluate(ctx));
    }
    evaluateOnce(token) {
        const r = this.operands.pop();
        const l = this.operands.pop();
        const result = operatorImpls[token](l, r);
        this.operands.push(result);
    }
}
function* tokenize(expr) {
    const N = expr.length;
    let str = '';
    const pairs = { '"': '"', "'": "'", '[': ']', '(': ')' };
    for (let i = 0; i < N; i++) {
        const c = expr[i];
        switch (c) {
            case '[':
            case '"':
            case "'":
                str += c;
                while (i + 1 < N) {
                    str += expr[++i];
                    if (expr[i] === pairs[c])
                        break;
                }
                break;
            case ' ':
            case '\t':
            case '\n':
                if (str)
                    yield str;
                str = '';
                break;
            default:
                str += c;
        }
    }
    if (str)
        yield str;
}
function* toPostfix(expr) {
    const ops = [];
    for (const token of tokenize(expr)) {
        if (isOperator(token)) {
            while (ops.length && precedence[ops[ops.length - 1]] > precedence[token]) {
                yield ops.pop();
            }
            ops.push(token);
        }
        else
            yield token;
    }
    while (ops.length) {
        yield ops.pop();
    }
}

class ParseStream {
    constructor(tokens, parseToken) {
        this.handlers = {};
        this.stopRequested = false;
        this.tokens = tokens;
        this.parseToken = parseToken;
    }
    on(name, cb) {
        this.handlers[name] = cb;
        return this;
    }
    trigger(event, arg) {
        const h = this.handlers[event];
        return h ? (h(arg), true) : false;
    }
    start() {
        this.trigger('start');
        let token;
        while (!this.stopRequested && (token = this.tokens.shift())) {
            if (this.trigger('token', token))
                continue;
            if (TagToken.is(token) && this.trigger(`tag:${token.name}`, token)) {
                continue;
            }
            const template = this.parseToken(token, this.tokens);
            this.trigger('template', template);
        }
        if (!this.stopRequested)
            this.trigger('end');
        return this;
    }
    stop() {
        this.stopRequested = true;
        return this;
    }
}

/**
 * Key-Value Pairs Representing Tag Arguments
 * Example:
 *    For the markup `{% include 'head.html' foo='bar' %}`,
 *    hash['foo'] === 'bar'
 */
class Hash {
    static parse(markup) {
        const instance = new Hash();
        let match;
        hashCapture.lastIndex = 0;
        while ((match = hashCapture.exec(markup))) {
            const k = match[1];
            const v = match[2];
            instance[k] = v;
        }
        return instance;
    }
    static *create(markup, ctx) {
        const instance = Hash.parse(markup);
        for (const key of Object.keys(instance)) {
            instance[key] = yield new Expression(instance[key]).evaluate(ctx);
        }
        return instance;
    }
}

class Tag extends Template {
    constructor(token, tokens, liquid) {
        super(token);
        this.name = token.name;
        const impl = Tag.impls[token.name];
        assert(impl, `tag ${token.name} not found`);
        this.impl = Object.create(impl);
        this.impl.liquid = liquid;
        if (this.impl.parse) {
            this.impl.parse(token, tokens);
        }
    }
    *render(ctx, emitter) {
        const hash = yield Hash.create(this.token.args, ctx);
        const impl = this.impl;
        if (isFunction(impl.render))
            return yield impl.render(ctx, hash, emitter);
    }
    static register(name, tag) {
        Tag.impls[name] = tag;
    }
    static clear() {
        Tag.impls = {};
    }
}
Tag.impls = {};

class Filter {
    constructor(name, args, strictFilters) {
        const impl = Filter.impls[name];
        if (!impl && strictFilters)
            throw new TypeError(`undefined filter: ${name}`);
        this.name = name;
        this.impl = impl || identify;
        this.args = args;
    }
    *render(value, context) {
        const argv = [];
        for (const arg of this.args) {
            if (isKeyValuePair(arg))
                argv.push([arg[0], yield new Expression(arg[1]).evaluate(context)]);
            else
                argv.push(yield new Expression(arg).evaluate(context));
        }
        return this.impl.apply({ context }, [value, ...argv]);
    }
    static register(name, filter) {
        Filter.impls[name] = filter;
    }
    static clear() {
        Filter.impls = {};
    }
}
Filter.impls = {};
function isKeyValuePair(arr) {
    return isArray(arr);
}

class Value$1 {
    /**
     * @param str value string, like: "i have a dream | truncate: 3
     */
    constructor(str, strictFilters) {
        this.filters = [];
        const tokens = Value$1.tokenize(str);
        this.strictFilters = strictFilters;
        this.initial = tokens[0];
        this.parseFilters(tokens, 1);
    }
    parseFilters(tokens, begin) {
        let i = begin;
        while (i < tokens.length) {
            if (tokens[i] !== '|') {
                i++;
                continue;
            }
            const j = ++i;
            while (i < tokens.length && tokens[i] !== '|')
                i++;
            this.parseFilter(tokens, j, i);
        }
    }
    parseFilter(tokens, begin, end) {
        const name = tokens[begin];
        const args = [];
        let argName, argValue;
        for (let i = begin + 1; i < end + 1; i++) {
            if (i === end || tokens[i] === ',') {
                if (argName || argValue) {
                    args.push(argName ? [argName, argValue] : argValue);
                }
                argValue = argName = undefined;
            }
            else if (tokens[i] === ':') {
                argName = argValue;
                argValue = undefined;
            }
            else if (argValue === undefined) {
                argValue = tokens[i];
            }
        }
        this.filters.push(new Filter(name, args, this.strictFilters));
    }
    *value(ctx) {
        let val = yield new Expression(this.initial).evaluate(ctx);
        for (const filter of this.filters) {
            val = yield filter.render(val, ctx);
        }
        return val;
    }
    static tokenize(str) {
        const tokens = [];
        let i = 0;
        while (i < str.length) {
            const ch = str[i];
            if (ch === '"' || ch === "'") {
                const j = i;
                for (i += 2; i < str.length && str[i - 1] !== ch; ++i)
                    ;
                tokens.push(str.slice(j, i));
            }
            else if (/\s/.test(ch)) {
                i++;
            }
            else if (/[|,:]/.test(ch)) {
                tokens.push(str[i++]);
            }
            else {
                const j = i++;
                let ch;
                for (; i < str.length && !/[|,:\s]/.test(ch = str[i]); ++i) {
                    if (ch === '"' || ch === "'") {
                        for (i += 2; i < str.length && str[i - 1] !== ch; ++i)
                            ;
                    }
                }
                tokens.push(str.slice(j, i));
            }
        }
        return tokens;
    }
}

class Output extends Template {
    constructor(token, strictFilters) {
        super(token);
        this.value = new Value$1(token.value, strictFilters);
    }
    *render(ctx, emitter) {
        const val = yield this.value.value(ctx);
        emitter.write(stringify(toValue(val)));
    }
}

class HTML extends Template {
    constructor(token) {
        super(token);
        this.str = token.value;
    }
    *render(ctx, emitter) {
        emitter.write(this.str);
    }
}

class Parser {
    constructor(liquid) {
        this.liquid = liquid;
    }
    parse(tokens) {
        let token;
        const templates = [];
        while ((token = tokens.shift())) {
            templates.push(this.parseToken(token, tokens));
        }
        return templates;
    }
    parseToken(token, remainTokens) {
        try {
            if (TagToken.is(token)) {
                return new Tag(token, remainTokens, this.liquid);
            }
            if (OutputToken.is(token)) {
                return new Output(token, this.liquid.options.strictFilters);
            }
            return new HTML(token);
        }
        catch (e) {
            throw new ParseError(e, token);
        }
    }
    parseStream(tokens) {
        return new ParseStream(tokens, (token, tokens) => this.parseToken(token, tokens));
    }
}

const re = new RegExp(`(${identifier.source})\\s*=([^]*)`);
var assign = {
    parse: function (token) {
        const match = token.args.match(re);
        assert(match, `illegal token ${token.raw}`);
        this.key = match[1];
        this.value = match[2];
    },
    render: function* (ctx) {
        ctx.front()[this.key] = yield this.liquid._evalValue(this.value, ctx);
    }
};

class ForloopDrop extends Drop {
    constructor(length) {
        super();
        this.i = 0;
        this.length = length;
    }
    next() {
        this.i++;
    }
    index0() {
        return this.i;
    }
    index() {
        return this.i + 1;
    }
    first() {
        return this.i === 0;
    }
    last() {
        return this.i === this.length - 1;
    }
    rindex() {
        return this.length - this.i;
    }
    rindex0() {
        return this.length - this.i - 1;
    }
    valueOf() {
        return JSON.stringify(this);
    }
}

const re$1 = new RegExp(`^(${identifier.source})\\s+in\\s+` +
    `(${value.source})` +
    `(?:\\s+${hash.source})*` +
    `(?:\\s+(reversed))?` +
    `(?:\\s+${hash.source})*$`);
var For = {
    type: 'block',
    parse: function (tagToken, remainTokens) {
        const match = re$1.exec(tagToken.args);
        assert(match, `illegal tag: ${tagToken.raw}`);
        this.variable = match[1];
        this.collection = match[2];
        this.reversed = !!match[3];
        this.templates = [];
        this.elseTemplates = [];
        let p;
        const stream = this.liquid.parser.parseStream(remainTokens)
            .on('start', () => (p = this.templates))
            .on('tag:else', () => (p = this.elseTemplates))
            .on('tag:endfor', () => stream.stop())
            .on('template', (tpl) => p.push(tpl))
            .on('end', () => {
            throw new Error(`tag ${tagToken.raw} not closed`);
        });
        stream.start();
    },
    render: function* (ctx, hash, emitter) {
        const r = this.liquid.renderer;
        let collection = yield new Expression(this.collection).value(ctx);
        if (!isArray(collection)) {
            if (isString(collection) && collection.length > 0) {
                collection = [collection];
            }
            else if (isObject(collection)) {
                collection = Object.keys(collection).map((key) => [key, collection[key]]);
            }
        }
        if (!isArray(collection) || !collection.length) {
            yield r.renderTemplates(this.elseTemplates, ctx, emitter);
            return;
        }
        const offset = hash.offset || 0;
        const limit = (hash.limit === undefined) ? collection.length : hash.limit;
        collection = collection.slice(offset, offset + limit);
        if (this.reversed)
            collection.reverse();
        const scope = { forloop: new ForloopDrop(collection.length) };
        ctx.push(scope);
        for (const item of collection) {
            scope[this.variable] = item;
            yield r.renderTemplates(this.templates, ctx, emitter);
            if (emitter.break) {
                emitter.break = false;
                break;
            }
            emitter.continue = false;
            scope.forloop.next();
        }
        ctx.pop();
    }
};

const re$2 = new RegExp(`(${identifier.source})`);
var capture = {
    parse: function (tagToken, remainTokens) {
        const match = tagToken.args.match(re$2);
        assert(match, `${tagToken.args} not valid identifier`);
        this.variable = match[1];
        this.templates = [];
        const stream = this.liquid.parser.parseStream(remainTokens);
        stream.on('tag:endcapture', () => stream.stop())
            .on('template', (tpl) => this.templates.push(tpl))
            .on('end', () => {
            throw new Error(`tag ${tagToken.raw} not closed`);
        });
        stream.start();
    },
    render: function* (ctx) {
        const r = this.liquid.renderer;
        const html = yield r.renderTemplates(this.templates, ctx);
        ctx.front()[this.variable] = html;
    }
};

var Case = {
    parse: function (tagToken, remainTokens) {
        this.cond = tagToken.args;
        this.cases = [];
        this.elseTemplates = [];
        let p = [];
        const stream = this.liquid.parser.parseStream(remainTokens)
            .on('tag:when', (token) => {
            this.cases.push({
                val: token.args,
                templates: p = []
            });
        })
            .on('tag:else', () => (p = this.elseTemplates))
            .on('tag:endcase', () => stream.stop())
            .on('template', (tpl) => p.push(tpl))
            .on('end', () => {
            throw new Error(`tag ${tagToken.raw} not closed`);
        });
        stream.start();
    },
    render: function* (ctx, hash, emitter) {
        const r = this.liquid.renderer;
        for (let i = 0; i < this.cases.length; i++) {
            const branch = this.cases[i];
            const val = yield new Expression(branch.val).value(ctx);
            const cond = yield new Expression(this.cond).value(ctx);
            if (val === cond) {
                yield r.renderTemplates(branch.templates, ctx, emitter);
                return;
            }
        }
        yield r.renderTemplates(this.elseTemplates, ctx, emitter);
    }
};

var comment = {
    parse: function (tagToken, remainTokens) {
        const stream = this.liquid.parser.parseStream(remainTokens);
        stream
            .on('token', (token) => {
            if (token.name === 'endcomment')
                stream.stop();
        })
            .on('end', () => {
            throw new Error(`tag ${tagToken.raw} not closed`);
        });
        stream.start();
    }
};

var BlockMode;
(function (BlockMode) {
    /* store rendered html into blocks */
    BlockMode[BlockMode["OUTPUT"] = 0] = "OUTPUT";
    /* output rendered html directly */
    BlockMode[BlockMode["STORE"] = 1] = "STORE";
})(BlockMode || (BlockMode = {}));
var BlockMode$1 = BlockMode;

const staticFileRE = /[^\s,]+/;
const withRE = new RegExp(`with\\s+(${value.source})`);
var include = {
    parse: function (token) {
        let match = staticFileRE.exec(token.args);
        if (match)
            this.staticValue = match[0];
        match = value.exec(token.args);
        if (match)
            this.value = match[0];
        match = withRE.exec(token.args);
        if (match)
            this.with = match[1];
    },
    render: function* (ctx, hash, emitter) {
        let filepath;
        if (ctx.opts.dynamicPartials) {
            if (quotedLine.exec(this.value)) {
                const template = this.value.slice(1, -1);
                filepath = yield this.liquid._parseAndRender(template, ctx.getAll(), ctx.opts, ctx.sync);
            }
            else {
                filepath = yield new Expression(this.value).value(ctx);
            }
        }
        else {
            filepath = this.staticValue;
        }
        assert(filepath, `cannot include with empty filename`);
        const originBlocks = ctx.getRegister('blocks');
        const originBlockMode = ctx.getRegister('blockMode');
        ctx.setRegister('blocks', {});
        ctx.setRegister('blockMode', BlockMode$1.OUTPUT);
        if (this.with) {
            hash[filepath] = yield new Expression(this.with).evaluate(ctx);
        }
        const templates = yield this.liquid._parseFile(filepath, ctx.opts, ctx.sync);
        ctx.push(hash);
        yield this.liquid.renderer.renderTemplates(templates, ctx, emitter);
        ctx.pop();
        ctx.setRegister('blocks', originBlocks);
        ctx.setRegister('blockMode', originBlockMode);
    }
};

const staticFileRE$1 = /[^\s,]+/;
const withRE$1 = new RegExp(`with\\s+(${value.source})`);
var render = {
    parse: function (token) {
        let match = staticFileRE$1.exec(token.args);
        if (match)
            this.staticValue = match[0];
        match = value.exec(token.args);
        if (match)
            this.value = match[0];
        match = withRE$1.exec(token.args);
        if (match)
            this.with = match[1];
    },
    render: function* (ctx, hash, emitter) {
        let filepath;
        if (ctx.opts.dynamicPartials) {
            if (quotedLine.exec(this.value)) {
                const template = this.value.slice(1, -1);
                filepath = yield this.liquid._parseAndRender(template, ctx.getAll(), ctx.opts, ctx.sync);
            }
            else {
                filepath = yield new Expression(this.value).value(ctx);
            }
        }
        else {
            filepath = this.staticValue;
        }
        assert(filepath, `cannot render with empty filename`);
        const originBlocks = ctx.getRegister('blocks');
        const originBlockMode = ctx.getRegister('blockMode');
        const childCtx = new Context({}, ctx.opts, ctx.sync);
        childCtx.setRegister('blocks', {});
        childCtx.setRegister('blockMode', BlockMode$1.OUTPUT);
        if (this.with) {
            hash[filepath] = yield new Expression(this.with).evaluate(ctx);
        }
        childCtx.push(hash);
        const templates = yield this.liquid._parseFile(filepath, childCtx.opts, childCtx.sync);
        yield this.liquid.renderer.renderTemplates(templates, childCtx, emitter);
        childCtx.setRegister('blocks', originBlocks);
        childCtx.setRegister('blockMode', originBlockMode);
    }
};

var decrement = {
    parse: function (token) {
        const match = token.args.match(identifier);
        assert(match, `illegal identifier ${token.args}`);
        this.variable = match[0];
    },
    render: function (context, hash, emitter) {
        const scope = context.environments;
        if (!isNumber(scope[this.variable])) {
            scope[this.variable] = 0;
        }
        emitter.write(stringify(--scope[this.variable]));
    }
};

const groupRE = new RegExp(`^(?:(${value.source})\\s*:\\s*)?(.*)$`);
const candidatesRE = new RegExp(value.source, 'g');
var cycle = {
    parse: function (tagToken) {
        let match = groupRE.exec(tagToken.args);
        assert(match, `illegal tag: ${tagToken.raw}`);
        this.group = new Expression(match[1]);
        const candidates = match[2];
        this.candidates = [];
        while ((match = candidatesRE.exec(candidates))) {
            this.candidates.push(match[0]);
        }
        assert(this.candidates.length, `empty candidates: ${tagToken.raw}`);
    },
    render: function* (ctx, hash, emitter) {
        const group = yield this.group.value(ctx);
        const fingerprint = `cycle:${group}:` + this.candidates.join(',');
        const groups = ctx.getRegister('cycle');
        let idx = groups[fingerprint];
        if (idx === undefined) {
            idx = groups[fingerprint] = 0;
        }
        const candidate = this.candidates[idx];
        idx = (idx + 1) % this.candidates.length;
        groups[fingerprint] = idx;
        const html = yield new Expression(candidate).value(ctx);
        emitter.write(html);
    }
};

var If = {
    parse: function (tagToken, remainTokens) {
        this.branches = [];
        this.elseTemplates = [];
        let p;
        const stream = this.liquid.parser.parseStream(remainTokens)
            .on('start', () => this.branches.push({
            cond: tagToken.args,
            templates: (p = [])
        }))
            .on('tag:elsif', (token) => {
            this.branches.push({
                cond: token.args,
                templates: p = []
            });
        })
            .on('tag:else', () => (p = this.elseTemplates))
            .on('tag:endif', () => stream.stop())
            .on('template', (tpl) => p.push(tpl))
            .on('end', () => {
            throw new Error(`tag ${tagToken.raw} not closed`);
        });
        stream.start();
    },
    render: function* (ctx, hash, emitter) {
        const r = this.liquid.renderer;
        for (const branch of this.branches) {
            const cond = yield new Expression(branch.cond).value(ctx);
            if (isTruthy(cond)) {
                yield r.renderTemplates(branch.templates, ctx, emitter);
                return;
            }
        }
        yield r.renderTemplates(this.elseTemplates, ctx, emitter);
    }
};

var increment = {
    parse: function (token) {
        const match = token.args.match(identifier);
        assert(match, `illegal identifier ${token.args}`);
        this.variable = match[0];
    },
    render: function (context, hash, emitter) {
        const scope = context.environments;
        if (!isNumber(scope[this.variable])) {
            scope[this.variable] = 0;
        }
        const val = scope[this.variable];
        scope[this.variable]++;
        emitter.write(stringify(val));
    }
};

const staticFileRE$2 = /\S+/;
var layout = {
    parse: function (token, remainTokens) {
        let match = staticFileRE$2.exec(token.args);
        if (match) {
            this.staticLayout = match[0];
        }
        match = value.exec(token.args);
        if (match) {
            this.layout = match[0];
        }
        this.tpls = this.liquid.parser.parse(remainTokens);
    },
    render: function* (ctx, hash, emitter) {
        const layout = ctx.opts.dynamicPartials
            ? yield new Expression(this.layout).value(ctx)
            : this.staticLayout;
        assert(layout, `cannot apply layout with empty filename`);
        // render the remaining tokens immediately
        ctx.setRegister('blockMode', BlockMode$1.STORE);
        const blocks = ctx.getRegister('blocks');
        const r = this.liquid.renderer;
        const html = yield r.renderTemplates(this.tpls, ctx);
        if (blocks[''] === undefined) {
            blocks[''] = html;
        }
        const templates = yield this.liquid._parseFile(layout, ctx.opts, ctx.sync);
        ctx.push(hash);
        ctx.setRegister('blockMode', BlockMode$1.OUTPUT);
        const partial = yield r.renderTemplates(templates, ctx);
        ctx.pop();
        emitter.write(partial);
    }
};

var block = {
    parse: function (token, remainTokens) {
        const match = /\w+/.exec(token.args);
        this.block = match ? match[0] : '';
        this.tpls = [];
        const stream = this.liquid.parser.parseStream(remainTokens)
            .on('tag:endblock', () => stream.stop())
            .on('template', (tpl) => this.tpls.push(tpl))
            .on('end', () => {
            throw new Error(`tag ${token.raw} not closed`);
        });
        stream.start();
    },
    render: function* (ctx, hash, emitter) {
        const blocks = ctx.getRegister('blocks');
        const childDefined = blocks[this.block];
        const r = this.liquid.renderer;
        const html = childDefined !== undefined
            ? childDefined
            : yield r.renderTemplates(this.tpls, ctx);
        if (ctx.getRegister('blockMode', BlockMode$1.OUTPUT) === BlockMode$1.STORE) {
            blocks[this.block] = html;
            return;
        }
        emitter.write(html);
    }
};

var raw = {
    parse: function (tagToken, remainTokens) {
        this.tokens = [];
        const stream = this.liquid.parser.parseStream(remainTokens);
        stream
            .on('token', (token) => {
            if (token.name === 'endraw')
                stream.stop();
            else
                this.tokens.push(token);
        })
            .on('end', () => {
            throw new Error(`tag ${tagToken.raw} not closed`);
        });
        stream.start();
    },
    render: function () {
        return this.tokens.map((token) => token.raw).join('');
    }
};

class TablerowloopDrop extends ForloopDrop {
    constructor(length, cols) {
        super(length);
        this.length = length;
        this.cols = cols;
    }
    row() {
        return Math.floor(this.i / this.cols) + 1;
    }
    col0() {
        return (this.i % this.cols);
    }
    col() {
        return this.col0() + 1;
    }
    col_first() {
        return this.col0() === 0;
    }
    col_last() {
        return this.col() === this.cols;
    }
}

const re$3 = new RegExp(`^(${identifier.source})\\s+in\\s+` +
    `(${value.source})` +
    `(?:\\s+${hash.source})*$`);
var tablerow = {
    parse: function (tagToken, remainTokens) {
        const match = re$3.exec(tagToken.args);
        assert(match, `illegal tag: ${tagToken.raw}`);
        this.variable = match[1];
        this.collection = match[2];
        this.templates = [];
        let p;
        const stream = this.liquid.parser.parseStream(remainTokens)
            .on('start', () => (p = this.templates))
            .on('tag:endtablerow', () => stream.stop())
            .on('template', (tpl) => p.push(tpl))
            .on('end', () => {
            throw new Error(`tag ${tagToken.raw} not closed`);
        });
        stream.start();
    },
    render: function* (ctx, hash, emitter) {
        let collection = (yield new Expression(this.collection).value(ctx)) || [];
        const offset = hash.offset || 0;
        const limit = (hash.limit === undefined) ? collection.length : hash.limit;
        collection = collection.slice(offset, offset + limit);
        const cols = hash.cols || collection.length;
        const r = this.liquid.renderer;
        const tablerowloop = new TablerowloopDrop(collection.length, cols);
        const scope = { tablerowloop };
        ctx.push(scope);
        for (let idx = 0; idx < collection.length; idx++, tablerowloop.next()) {
            scope[this.variable] = collection[idx];
            if (tablerowloop.col0() === 0) {
                if (tablerowloop.row() !== 1)
                    emitter.write('</tr>');
                emitter.write(`<tr class="row${tablerowloop.row()}">`);
            }
            emitter.write(`<td class="col${tablerowloop.col()}">`);
            yield r.renderTemplates(this.templates, ctx, emitter);
            emitter.write('</td>');
        }
        if (collection.length)
            emitter.write('</tr>');
        ctx.pop();
    }
};

var unless = {
    parse: function (tagToken, remainTokens) {
        this.templates = [];
        this.elseTemplates = [];
        let p;
        const stream = this.liquid.parser.parseStream(remainTokens)
            .on('start', () => {
            p = this.templates;
            this.cond = tagToken.args;
        })
            .on('tag:else', () => (p = this.elseTemplates))
            .on('tag:endunless', () => stream.stop())
            .on('template', tpl => p.push(tpl))
            .on('end', () => {
            throw new Error(`tag ${tagToken.raw} not closed`);
        });
        stream.start();
    },
    render: function* (ctx, hash, emitter) {
        const r = this.liquid.renderer;
        const cond = yield new Expression(this.cond).value(ctx);
        yield (isFalsy(cond)
            ? r.renderTemplates(this.templates, ctx, emitter)
            : r.renderTemplates(this.elseTemplates, ctx, emitter));
    }
};

var Break = {
    render: function (ctx, hash, emitter) {
        emitter.break = true;
    }
};

var Continue = {
    render: function (ctx, hash, emitter) {
        emitter.continue = true;
    }
};

const tags = {
    assign, 'for': For, capture, 'case': Case, comment, include, render, decrement, increment, cycle, 'if': If, layout, block, raw, tablerow, unless, 'break': Break, 'continue': Continue
};

const escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&#34;',
    "'": '&#39;'
};
const unescapeMap = {
    '&amp;': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&#34;': '"',
    '&#39;': "'"
};
function escape(str) {
    return stringify(str).replace(/&|<|>|"|'/g, m => escapeMap[m]);
}
function unescape(str) {
    return String(str).replace(/&(amp|lt|gt|#34|#39);/g, m => unescapeMap[m]);
}
var html = {
    'escape': escape,
    'escape_once': (str) => escape(unescape(str)),
    'newline_to_br': (v) => v.replace(/\n/g, '<br />'),
    'strip_html': (v) => v.replace(/<script.*?<\/script>|<!--.*?-->|<style.*?<\/style>|<.*?>/g, '')
};

/**
 * String related filters
 *
 * * prefer stringify() to String() since `undefined`, `null` should eval ''
 */
var str = {
    'append': (v, arg) => stringify(v) + stringify(arg),
    'prepend': (v, arg) => stringify(arg) + stringify(v),
    'capitalize': capitalize,
    'lstrip': (v) => stringify(v).replace(/^\s+/, ''),
    'downcase': (v) => stringify(v).toLowerCase(),
    'upcase': (str) => stringify(str).toUpperCase(),
    'remove': (v, arg) => stringify(v).split(arg).join(''),
    'remove_first': (v, l) => stringify(v).replace(l, ''),
    'replace': replace,
    'replace_first': replaceFirst,
    'rstrip': (str) => stringify(str).replace(/\s+$/, ''),
    'split': (v, arg) => stringify(v).split(arg),
    'strip': (v) => stringify(v).trim(),
    'strip_newlines': (v) => stringify(v).replace(/\n/g, ''),
    'truncate': truncate,
    'truncatewords': truncateWords
};
function capitalize(str) {
    str = stringify(str);
    return str.charAt(0).toUpperCase() + str.slice(1);
}
function replace(v, pattern, replacement) {
    return stringify(v).split(pattern).join(replacement);
}
function replaceFirst(v, arg1, arg2) {
    return stringify(v).replace(arg1, arg2);
}
function truncate(v, l = 50, o = '...') {
    v = stringify(v);
    if (v.length <= l)
        return v;
    return v.substr(0, l - o.length) + o;
}
function truncateWords(v, l = 15, o = '...') {
    const arr = v.split(/\s+/);
    let ret = arr.slice(0, l).join(' ');
    if (arr.length >= l)
        ret += o;
    return ret;
}

const toLowerCase = String.prototype.toLowerCase;
var math = {
    'abs': (v) => Math.abs(v),
    'at_least': (v, n) => Math.max(v, n),
    'at_most': (v, n) => Math.min(v, n),
    'ceil': (v) => Math.ceil(v),
    'divided_by': (v, arg) => v / arg,
    'floor': (v) => Math.floor(v),
    'minus': (v, arg) => v - arg,
    'modulo': (v, arg) => v % arg,
    'round': (v, arg = 0) => {
        const amp = Math.pow(10, arg);
        return Math.round(v * amp) / amp;
    },
    'plus': (v, arg) => Number(v) + Number(arg),
    'sort_natural': sortNatural,
    'times': (v, arg) => v * arg
};
function caseInsensitiveCmp(a, b) {
    if (!b)
        return -1;
    if (!a)
        return 1;
    a = toLowerCase.call(a);
    b = toLowerCase.call(b);
    if (a < b)
        return -1;
    if (a > b)
        return 1;
    return 0;
}
function sortNatural(input, property) {
    if (!input || !input.sort)
        return [];
    if (property !== undefined) {
        return [...input].sort((lhs, rhs) => caseInsensitiveCmp(lhs[property], rhs[property]));
    }
    return [...input].sort(caseInsensitiveCmp);
}

var url = {
    'url_decode': (x) => x.split('+').map(decodeURIComponent).join(' '),
    'url_encode': (x) => x.split(' ').map(encodeURIComponent).join('+')
};

var array = {
    'join': (v, arg) => v.join(arg === undefined ? ' ' : arg),
    'last': (v) => isArray(v) ? last(v) : '',
    'first': (v) => isArray(v) ? v[0] : '',
    'map': map,
    'reverse': (v) => [...v].reverse(),
    'sort': (v, arg) => v.sort(arg),
    'size': (v) => (v && v.length) || 0,
    'concat': concat,
    'slice': slice,
    'uniq': uniq,
    'where': where
};
function map(arr, arg) {
    return arr.map(v => v[arg]);
}
function concat(v, arg) {
    return Array.prototype.concat.call(v, arg);
}
function slice(v, begin, length = 1) {
    begin = begin < 0 ? v.length + begin : begin;
    return v.slice(begin, begin + length);
}
function where(arr, property, expected) {
    return arr.filter(obj => {
        const value = this.context.getFromScope(obj, property);
        return expected === undefined ? isTruthy(value) : value === expected;
    });
}
function uniq(arr) {
    const u = {};
    return (arr || []).filter(val => {
        if (u.hasOwnProperty(String(val)))
            return false;
        u[String(val)] = true;
        return true;
    });
}

const rFormat = /%([-_0^#:]+)?(\d+)?([EO])?(.)/;
const monthNames = [
    'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August',
    'September', 'October', 'November', 'December'
];
const dayNames = [
    'Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'
];
const monthNamesShort = monthNames.map(abbr);
const dayNamesShort = dayNames.map(abbr);
const suffixes = {
    1: 'st',
    2: 'nd',
    3: 'rd',
    'default': 'th'
};
function abbr(str) {
    return str.slice(0, 3);
}
// prototype extensions
function daysInMonth(d) {
    const feb = isLeapYear(d) ? 29 : 28;
    return [31, feb, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
}
function getDayOfYear(d) {
    let num = 0;
    for (let i = 0; i < d.getMonth(); ++i) {
        num += daysInMonth(d)[i];
    }
    return num + d.getDate();
}
function getWeekOfYear(d, startDay) {
    // Skip to startDay of this week
    const now = getDayOfYear(d) + (startDay - d.getDay());
    // Find the first startDay of the year
    const jan1 = new Date(d.getFullYear(), 0, 1);
    const then = (7 - jan1.getDay() + startDay);
    return String(Math.floor((now - then) / 7) + 1);
}
function isLeapYear(d) {
    const year = d.getFullYear();
    return !!((year & 3) === 0 && (year % 100 || (year % 400 === 0 && year)));
}
function getSuffix(d) {
    const str = d.getDate().toString();
    const index = parseInt(str.slice(-1));
    return suffixes[index] || suffixes['default'];
}
function century(d) {
    return parseInt(d.getFullYear().toString().substring(0, 2), 10);
}
// default to 0
const padWidths = {
    d: 2,
    e: 2,
    H: 2,
    I: 2,
    j: 3,
    k: 2,
    l: 2,
    L: 3,
    m: 2,
    M: 2,
    S: 2,
    U: 2,
    W: 2
};
// default to '0'
const padChars = {
    a: ' ',
    A: ' ',
    b: ' ',
    B: ' ',
    c: ' ',
    e: ' ',
    k: ' ',
    l: ' ',
    p: ' ',
    P: ' '
};
const formatCodes = {
    a: (d) => dayNamesShort[d.getDay()],
    A: (d) => dayNames[d.getDay()],
    b: (d) => monthNamesShort[d.getMonth()],
    B: (d) => monthNames[d.getMonth()],
    c: (d) => d.toLocaleString(),
    C: (d) => century(d),
    d: (d) => d.getDate(),
    e: (d) => d.getDate(),
    H: (d) => d.getHours(),
    I: (d) => String(d.getHours() % 12 || 12),
    j: (d) => getDayOfYear(d),
    k: (d) => d.getHours(),
    l: (d) => String(d.getHours() % 12 || 12),
    L: (d) => d.getMilliseconds(),
    m: (d) => d.getMonth() + 1,
    M: (d) => d.getMinutes(),
    N: (d, opts) => {
        const width = Number(opts.width) || 9;
        const str = String(d.getMilliseconds()).substr(0, width);
        return padEnd(str, width, '0');
    },
    p: (d) => (d.getHours() < 12 ? 'AM' : 'PM'),
    P: (d) => (d.getHours() < 12 ? 'am' : 'pm'),
    q: (d) => getSuffix(d),
    s: (d) => Math.round(d.valueOf() / 1000),
    S: (d) => d.getSeconds(),
    u: (d) => d.getDay() || 7,
    U: (d) => getWeekOfYear(d, 0),
    w: (d) => d.getDay(),
    W: (d) => getWeekOfYear(d, 1),
    x: (d) => d.toLocaleDateString(),
    X: (d) => d.toLocaleTimeString(),
    y: (d) => d.getFullYear().toString().substring(2, 4),
    Y: (d) => d.getFullYear(),
    z: (d, opts) => {
        const offset = d.getTimezoneOffset();
        const nOffset = Math.abs(offset);
        const h = Math.floor(nOffset / 60);
        const m = nOffset % 60;
        return (offset > 0 ? '-' : '+') +
            padStart(h, 2, '0') +
            (opts.flags[':'] ? ':' : '') +
            padStart(m, 2, '0');
    },
    't': () => '\t',
    'n': () => '\n',
    '%': () => '%'
};
formatCodes.h = formatCodes.b;
function strftime (d, formatStr) {
    let output = '';
    let remaining = formatStr;
    let match;
    while ((match = rFormat.exec(remaining))) {
        output += remaining.slice(0, match.index);
        remaining = remaining.slice(match.index + match[0].length);
        output += format(d, match);
    }
    return output + remaining;
}
function format(d, match) {
    const [input, flagStr = '', width, modifier, conversion] = match;
    const convert = formatCodes[conversion];
    if (!convert)
        return input;
    const flags = {};
    for (const flag of flagStr)
        flags[flag] = true;
    let ret = String(convert(d, { flags, width, modifier }));
    let padChar = padChars[conversion] || '0';
    let padWidth = width || padWidths[conversion] || 0;
    if (flags['^'])
        ret = ret.toUpperCase();
    else if (flags['#'])
        ret = changeCase(ret);
    if (flags['_'])
        padChar = ' ';
    else if (flags['0'])
        padChar = '0';
    if (flags['-'])
        padWidth = 0;
    return padStart(ret, padWidth, padChar);
}

var date = {
    'date': (v, arg) => {
        let date = v;
        if (v === 'now') {
            date = new Date();
        }
        else if (isNumber(v)) {
            date = new Date(v * 1000);
        }
        else if (isString(v)) {
            date = /^\d+$/.test(v) ? new Date(+v * 1000) : new Date(v);
        }
        return isValidDate(date) ? strftime(date, arg) : v;
    }
};
function isValidDate(date) {
    return date instanceof Date && !isNaN(date.getTime());
}

var obj = {
    'default': function (v, arg) {
        return isFalsy(toValue(v)) || v === '' ? arg : v;
    }
};

var builtinFilters = Object.assign({}, html, str, math, url, date, obj, array);

function mkResolve(value) {
    const ret = {
        then: (resolve) => resolve(value),
        catch: () => ret
    };
    return ret;
}
function mkReject(err) {
    const ret = {
        then: (resolve, reject) => {
            if (reject)
                return reject(err);
            return ret;
        },
        catch: (reject) => reject(err)
    };
    return ret;
}
function isThenable(val) {
    return val && isFunction(val.then);
}
function isCustomIterable(val) {
    return val && isFunction(val.next) && isFunction(val.throw) && isFunction(val.return);
}
function toThenable(val) {
    if (isThenable(val))
        return val;
    if (isCustomIterable(val))
        return reduce();
    return mkResolve(val);
    function reduce(prev) {
        let state;
        try {
            state = val.next(prev);
        }
        catch (err) {
            return mkReject(err);
        }
        if (state.done)
            return mkResolve(state.value);
        return toThenable(state.value).then(reduce, err => {
            let state;
            try {
                state = val.throw(err);
            }
            catch (e) {
                return mkReject(e);
            }
            if (state.done)
                return mkResolve(state.value);
            return reduce(state.value);
        });
    }
}
function toValue$1(val) {
    let ret;
    toThenable(val)
        .then((x) => {
        ret = x;
        return mkResolve(ret);
    })
        .catch((err) => {
        throw err;
    });
    return ret;
}

class Liquid {
    constructor(opts = {}) {
        this.cache = {};
        this.options = applyDefault(normalize(opts));
        this.parser = new Parser(this);
        this.renderer = new Render();
        this.tokenizer = new Tokenizer(this.options);
        this.fs = opts.fs || fs;
        forOwn(tags, (conf, name) => this.registerTag(name, conf));
        forOwn(builtinFilters, (handler, name) => this.registerFilter(name, handler));
    }
    parse(html, filepath) {
        const tokens = this.tokenizer.tokenize(html, filepath);
        return this.parser.parse(tokens);
    }
    _render(tpl, scope, opts, sync) {
        const options = Object.assign({}, this.options, normalize(opts));
        const ctx = new Context(scope, options, sync);
        return this.renderer.renderTemplates(tpl, ctx);
    }
    async render(tpl, scope, opts) {
        return toThenable(this._render(tpl, scope, opts, false));
    }
    renderSync(tpl, scope, opts) {
        return toValue$1(this._render(tpl, scope, opts, true));
    }
    _parseAndRender(html, scope, opts, sync) {
        const tpl = this.parse(html);
        return this._render(tpl, scope, opts, sync);
    }
    async parseAndRender(html, scope, opts) {
        return toThenable(this._parseAndRender(html, scope, opts, false));
    }
    parseAndRenderSync(html, scope, opts) {
        return toValue$1(this._parseAndRender(html, scope, opts, true));
    }
    *_parseFile(file, opts, sync) {
        const options = Object.assign({}, this.options, normalize(opts));
        const paths = options.root.map(root => this.fs.resolve(root, file, options.extname));
        if (fs.fallback !== undefined) {
            const filepath = fs.fallback(file);
            if (filepath !== undefined)
                paths.push(filepath);
        }
        for (const filepath of paths) {
            if (this.options.cache && this.cache[filepath])
                return this.cache[filepath];
            if (!(sync ? this.fs.existsSync(filepath) : yield this.fs.exists(filepath)))
                continue;
            const tpl = this.parse(sync ? fs.readFileSync(filepath) : yield this.fs.readFile(filepath), filepath);
            return (this.cache[filepath] = tpl);
        }
        throw this.lookupError(file, options.root);
    }
    async parseFile(file, opts) {
        return toThenable(this._parseFile(file, opts, false));
    }
    parseFileSync(file, opts) {
        return toValue$1(this._parseFile(file, opts, true));
    }
    async renderFile(file, ctx, opts) {
        const templates = await this.parseFile(file, opts);
        return this.render(templates, ctx, opts);
    }
    renderFileSync(file, ctx, opts) {
        const options = normalize(opts);
        const templates = this.parseFileSync(file, options);
        return this.renderSync(templates, ctx, opts);
    }
    _evalValue(str, ctx) {
        const value = new Value$1(str, this.options.strictFilters);
        return value.value(ctx);
    }
    async evalValue(str, ctx) {
        return toThenable(this._evalValue(str, ctx));
    }
    evalValueSync(str, ctx) {
        return toValue$1(this._evalValue(str, ctx));
    }
    registerFilter(name, filter) {
        return Filter.register(name, filter);
    }
    registerTag(name, tag) {
        return Tag.register(name, tag);
    }
    plugin(plugin) {
        return plugin.call(this, Liquid);
    }
    express() {
        const self = this; // eslint-disable-line
        return function (filePath, ctx, cb) {
            const opts = { root: [...normalizeStringArray(this.root), ...self.options.root] };
            self.renderFile(filePath, ctx, opts).then(html => cb(null, html), cb);
        };
    }
    lookupError(file, roots) {
        const err = new Error('ENOENT');
        err.message = `ENOENT: Failed to lookup "${file}" in "${roots}"`;
        err.code = 'ENOENT';
        return err;
    }
    /**
     * @deprecated use parseFile instead
     */
    async getTemplate(file, opts) {
        return this.parseFile(file, opts);
    }
    /**
     * @deprecated use parseFileSync instead
     */
    getTemplateSync(file, opts) {
        return this.parseFileSync(file, opts);
    }
}

export { AssertionError, Context, Drop, Emitter, Expression, Hash, Liquid, ParseError, ParseStream, TagToken, Token, TokenizationError, isFalsy, isTruthy };
